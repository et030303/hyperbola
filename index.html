<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŒê³¡ì„ ì˜ íŠ¹ì§• by ET</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Pretendard', sans-serif; }
        
        #header { position: absolute; top: 0; width: 100%; background: #1a1a2e; color: white; text-align: center; padding: 12px 0; font-size: 24px; font-weight: 800; z-index: 1002; letter-spacing: 1px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        #header span { color: #00d2ff; font-size: 16px; font-weight: normal; margin-left: 8px; }
        
        #menu { position: absolute; top: 52px; width: 100%; display: flex; justify-content: center; background: rgba(255, 255, 255, 0.95); box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; }
        .tab { padding: 15px 25px; cursor: pointer; border-bottom: 3px solid transparent; font-weight: bold; color: #555; transition: 0.3s; }
        .tab.active { border-bottom: 3px solid #007bff; color: #007bff; }
        
        #ui-layer { position: absolute; top: 120px; left: 20px; z-index: 1001; display: flex; flex-direction: column; gap: 10px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .ui-item { display: flex; align-items: center; gap: 8px; }
        .ui-item label { font-size: 14px; font-weight: bold; color: #333; min-width: 90px; }

        button { padding: 10px 15px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: background 0.2s; }
        button:hover { filter: brightness(1.1); }
        button.reset { background: #ff3b30; margin-top: 5px; }
        button.info { background: #17a2b8; margin-top: 5px; }
        button.switch { background: #ff9500; display: none; margin-top: 5px; color: white;} 
        
        input[type=range] { -webkit-appearance: none; width: 140px; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none; transition: .2s; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #007bff; cursor: pointer; box-shadow: 0 0 5px rgba(0,0,0,0.2); }
        
        #angleUi { display: none; align-items: center; background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 8px; font-weight: bold; font-size: 14px; color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; border: 2px solid #007bff; margin-top: 5px;}
        #angleUi input { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }

        #infoBox { display: none; position: absolute; top: 120px; right: 20px; width: 320px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border-left: 5px solid #17a2b8; font-size: 14px; line-height: 1.6; color: #333; z-index: 1001; }
        #infoBox h3 { margin-top: 0; margin-bottom: 12px; color: #17a2b8; font-size: 18px; }

        /* ìˆ˜ì‹ í‘œì‹œë¥¼ ìœ„í•œ CSS */
        #mathBox { display: none; position: absolute; bottom: 40px; left: 20px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border-left: 5px solid #007bff; font-size: 14px; line-height: 1.6; color: #333; z-index: 1001; pointer-events: none; max-height: 80vh; overflow-y: auto; }
        .frac { display: inline-block; position: relative; vertical-align: middle; letter-spacing: 0.001em; text-align: center; margin: 0 4px; }
        .frac > span { display: block; padding: 0.1em; }
        .frac span.bottom { border-top: 2px solid #333; }

        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 12px 24px; border-radius: 30px; font-size: 14px; pointer-events: none; z-index: 1001; text-align: center; line-height: 1.5; white-space: nowrap; }
    </style>
</head>
<body>

<div id="header">ìŒê³¡ì„ ì˜ íŠ¹ì§•<span>by ET</span></div>

<div id="menu">
    <div id="tab1" class="tab active" onclick="setMode(1)">1. ìì·¨ ì‘ë„</div>
    <div id="tab2" class="tab" onclick="setMode(2)">2. ì •ì˜ í•™ìŠµ</div>
    <div id="tab3" class="tab" onclick="setMode(3)">3. ê´‘í•™ ì„±ì§ˆ</div>
</div>

<div id="ui-layer">
    <div class="ui-item">
        <label>ì´ˆì  ê±°ë¦¬ (2c):</label>
        <input type="range" id="cSlider" min="200" max="600" value="300" step="10">
        <span id="cValue">300</span>
    </div>
    <div class="ui-item">
        <label>ê±°ë¦¬ì˜ ì°¨ (2a):</label>
        <input type="range" id="aSlider" min="50" max="400" value="160" step="10">
        <span id="aValue">160</span>
    </div>
    <button id="resetBtn" class="reset" onclick="resetData()">ë°ì´í„° ì´ˆê¸°í™”</button>
    <button onclick="resetView()">í™”ë©´ ìœ„ì¹˜ ì´ˆê¸°í™”</button>
    
    <button id="lightSwitchBtn" class="switch" onclick="toggleLightSource()">ğŸ¯ íƒ€ê²Ÿ ì´ˆì  ë³€ê²½ (í˜„ì¬: Fâ‚)</button>
    <label id="angleUi">
        <input type="checkbox" id="angleCheck"> ì…ì‚¬ê° / ë°˜ì‚¬ê° ë³´ê¸°
    </label>

    <button id="infoToggleBtn" class="info" onclick="toggleInfo()">ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°</button>
</div>

<div id="mathBox"></div>

<div id="infoBox"></div>
<div id="instructions"></div>

<script>
    let mode = 1;
    let zoom = 1.0;
    let offsetX = 0, offsetY = 0;
    
    let c = 150; 
    let a = 80;  

    let tracePoints = [];
    let activeY = null;
    let activeBranch = 1;
    let rays = [];
    let activeLightTarget = 1; 

    let isInfoOpen = false;
    const conceptTexts = {
        1: "<h3>ìì·¨ ì‘ë„ ì›ë¦¬</h3>ìŒê³¡ì„ ì€ <b>ë‘ ì´ˆì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ì˜ ì°¨ê°€ ì¼ì •í•œ ì ë“¤ì˜ ì§‘í•©</b>ì…ë‹ˆë‹¤.<br><br>ë§ˆìš°ìŠ¤ë¥¼ ìœ„ì•„ë˜ë¡œ ì›€ì§ì—¬ ê¶¤ì ì„ ê·¸ë ¤ë³´ì„¸ìš”. ê·¸ë ¤ì§€ëŠ” ì ê³¼ ë‘ ì´ˆì  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•´ ë³´ë©´ ê·¸ <b>ì°¨ì´ê°€ í•­ìƒ ì¼ì •(2a)</b>í•¨ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        2: "<h3>ìŒê³¡ì„ ì˜ ì •ì˜ì™€ ì ê·¼ì„ </h3>ì–´ëŠ ìœ„ì¹˜ì— ìˆë“  <b>ë‘ ì´ˆì ê¹Œì§€ì˜ ê±°ë¦¬ì˜ ì°¨ê°€ í•­ìƒ ì¼ì •(2a)</b>í•©ë‹ˆë‹¤.<br><br>ì¤‘ì‹¬ì„ ì§€ë‚˜ëŠ” <b>íšŒìƒ‰ ì ì„ ì€ ìŒê³¡ì„ ì˜ ì ê·¼ì„ </b>ì…ë‹ˆë‹¤. ìŒê³¡ì„ ì´ ë»—ì–´ ë‚˜ê°ˆìˆ˜ë¡ ì´ ì„ ì— ë¬´í•œíˆ ê°€ê¹Œì›Œì§€ì§€ë§Œ ê²°ì½” ë§Œë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
        3: "<h3>ìŒê³¡ì„ ì˜ ê´‘í•™ì  ì„±ì§ˆ</h3>ì™¸ë¶€ì—ì„œ <b>í•œ ì´ˆì ì„ í–¥í•´ ë˜‘ë°”ë¡œ ìœ ë¹›</b>ì€ ìŒê³¡ì„  ë©´ì— ë¶€ë”ªíˆë©´ <b>ë°˜ëŒ€í¸ ì´ˆì ì„ í–¥í•´ ë°˜ì‚¬</b>ë©ë‹ˆë‹¤.<br><br>ë§ˆìš°ìŠ¤(ì†ì „ë“±)ë¡œ íƒ€ê²Ÿ ì´ˆì ì„ í–¥í•´ ë¹›ì„ ì´ë³´ì„¸ìš”. ê±°ìš¸ì— ë°˜ì‚¬ëœ ë¹›ì´ ì •í™•íˆ ë°˜ëŒ€í¸ ì´ˆì ìœ¼ë¡œ ëª¨ì´ê±°ë‚˜ í¼ì§€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."
    };

    function setup() {
        createCanvas(windowWidth, windowHeight);
        document.oncontextmenu = () => false;

        let cSlider = select('#cSlider');
        let aSlider = select('#aSlider');
        let cVal = select('#cValue');
        let aVal = select('#aValue');

        cSlider.input(() => {
            c = cSlider.value() / 2;
            cVal.html(cSlider.value());
            if (cSlider.value() <= aSlider.value()) {
                aSlider.value(parseInt(cSlider.value()) - 20);
                aVal.html(aSlider.value());
                a = aSlider.value() / 2;
            }
            updateMathInfo();
            resetData();
        });

        aSlider.input(() => {
            if (aSlider.value() >= cSlider.value()) {
                aSlider.value(parseInt(cSlider.value()) - 20);
            }
            a = aSlider.value() / 2;
            aVal.html(aSlider.value());
            updateMathInfo();
            resetData();
        });

        updateMathInfo();
        updateInstruction();
    }

    // 2ë²ˆ ëª¨ë“œì—ì„œ ìˆ˜ì‹ ì •ë³´ í‘œì‹œ ì—…ë°ì´íŠ¸ (dynamicDataê°€ ìˆìœ¼ë©´ í•˜ë‹¨ì— ì¶”ê°€)
    function updateMathInfo(dynamicData = null) {
        let bSq = c*c - a*a;
        let bVal = sqrt(bSq).toFixed(1);
        let slope = (sqrt(bSq) / a).toFixed(2);
        
        let baseHtml = `
            <div style="font-size:15px; margin-bottom:10px; color:#007bff; font-weight:bold;">[ ì‹¤ì‹œê°„ ìŒê³¡ì„ ì˜ ë°©ì •ì‹ ]</div>
            
            <div style="display:flex; justify-content:center; align-items:center; font-size: 18px; margin-bottom:15px; font-family: serif;">
                <div class="frac"><span>x<sup>2</sup></span><span class="bottom">${a*a}</span></div>
                <span style="margin:0 8px;">-</span>
                <div class="frac"><span>y<sup>2</sup></span><span class="bottom">${bSq}</span></div>
                <span style="margin:0 8px;">= 1</span>
            </div>
            
            <hr style="border:0; border-top:1px dashed #ccc; margin:10px 0;">
            
            <div style="font-size:14px; line-height: 1.8;">
                <b>â€¢ ìƒìˆ˜:</b> a = ${a},&nbsp;&nbsp; c = ${c}<br>
                <span style="color:#666; font-size:13px;">( b<sup>2</sup> = c<sup>2</sup> - a<sup>2</sup> = ${bSq} &nbsp;â”&nbsp; b â‰ˆ ${bVal} )</span><br>
                <b>â€¢ ì´ˆì (F):</b> (${c}, 0), (-${c}, 0)<br>
                <b>â€¢ ê¼­ì§“ì :</b> (${a}, 0), (-${a}, 0)<br>
                <b>â€¢ ì ê·¼ì„ :</b> y = Â± ${slope}x
            </div>
        `;

        if (dynamicData) {
            baseHtml += `
                <hr style="border:0; border-top:2px solid #ff3b30; margin:15px 0 10px 0;">
                <div style="font-size:14px; color:#333; line-height:1.6;">
                    <b style="color:#ff3b30;">[ í˜„ì¬ í´ë¦­í•œ ì ì—ì„œì˜ ê±°ë¦¬ ]</b><br>
                    dâ‚ (Fâ‚ê¹Œì§€) = <span style="color:#22c55e; font-weight:bold;">${dynamicData.d1}</span><br>
                    dâ‚‚ (Fâ‚‚ê¹Œì§€) = <span style="color:#22c55e; font-weight:bold;">${dynamicData.d2}</span><br>
                    <div style="margin-top:8px; font-size:16px; color:#ff3b30; font-weight:bold; text-align:center; background:rgba(255,59,48,0.1); padding:8px; border-radius:8px;">
                         ê±°ë¦¬ì˜ ì°¨ |dâ‚ - dâ‚‚| = ${dynamicData.diff} (ì¼ì •)
                    </div>
                </div>
            `;
        }
        document.getElementById('mathBox').innerHTML = baseHtml;
    }

    function draw() {
        background(255);
        
        push();
        translate(width/2 + offsetX, height/2 + offsetY);
        scale(zoom);
        drawGrid();

        if (mode === 1) runMode1();
        else if (mode === 2) {
             // ìƒë‹¨ ë©”ë‰´ë°” ë†’ì´(ì•½ 120px)ë¥¼ ê³ ë ¤í•˜ì—¬ Yì¶• ìƒë‹¨ í´ë¦¬í•‘ ì¢Œí‘œ ê³„ì‚°
             let clipYWorld = (-height/2 - offsetY + 120) / zoom;
             drawAxes(clipYWorld); 
             runMode2();
        }
        else if (mode === 3) runMode3();
        
        pop();
    }

    // 2ë²ˆ ëª¨ë“œ ì „ìš© ì¶• ê·¸ë¦¬ê¸° í•¨ìˆ˜ (í™”ì‚´í‘œ & ë ˆì´ë¸” ê°œì„ )
    function drawAxes(clipY) {
        push();
        // í™”ë©´ ë·°í¬íŠ¸ì— ë§ì¶˜ ì¶• ëì  ê³„ì‚° (í™”ë©´ ë°–ìœ¼ë¡œ ë„˜ì–´ê°€ì§€ ì•Šê²Œ íŒ¨ë”©ì„ ì¤Œ)
        let rightEdge = (width/2 - offsetX) / zoom - 40/zoom; 
        let leftEdge = (-width/2 - offsetX) / zoom;
        let bottomEdge = (height/2 - offsetY) / zoom;
        let topEdge = clipY; 

        // Xì¶•
        stroke(0); strokeWeight(1.5/zoom); noFill();
        line(-3000, 0, rightEdge, 0); 
        
        // Xì¶• í™”ì‚´í‘œ (ìƒ‰ì¹ ëœ ì‚¼ê°í˜•)
        fill(0); noStroke();
        triangle(rightEdge, 0, rightEdge - 15/zoom, 6/zoom, rightEdge - 15/zoom, -6/zoom);
        
        // x ë ˆì´ë¸”
        textAlign(LEFT, CENTER); textSize(18/zoom); textStyle(ITALIC);
        text("x", rightEdge + 10/zoom, 0);

        // Yì¶•
        stroke(0); strokeWeight(1.5/zoom);
        line(0, 3000, 0, topEdge); 
        
        // Yì¶• í™”ì‚´í‘œ (ìƒ‰ì¹ ëœ ì‚¼ê°í˜•)
        fill(0); noStroke();
        triangle(0, topEdge, -6/zoom, topEdge + 15/zoom, 6/zoom, topEdge + 15/zoom);
        
        // y ë ˆì´ë¸”
        textAlign(CENTER, BOTTOM);
        text("y", 0, topEdge - 10/zoom);

        // ì›ì (O) ë ˆì´ë¸”
        fill(0); textAlign(RIGHT, TOP); textStyle(NORMAL); textSize(16/zoom);
        text("O", -8/zoom, 8/zoom);
        pop();
    }

    function drawSubText(mainText, subText, x, y, size, col) {
        push();
        fill(col || 0); noStroke();
        textSize(size);
        let wMain = textWidth(mainText);
        textSize(size * 0.7);
        let wSub = textWidth(subText);
        let totalW = wMain + wSub;
        let startX = x - totalW / 2;
        
        textAlign(LEFT, BASELINE);
        textSize(size);
        text(mainText, startX, y);
        textSize(size * 0.7);
        text(subText, startX + wMain, y + size * 0.25);
        pop();
    }

    function drawHyperbolaLines(a, b, col, weight) {
        noFill(); stroke(col); strokeWeight(weight);
        beginShape();
        for (let y = -1500/zoom; y <= 1500/zoom; y += 10/zoom) {
            let x = a * sqrt(1 + (y*y)/(b*b));
            vertex(x, y);
        }
        endShape();
        beginShape();
        for (let y = -1500/zoom; y <= 1500/zoom; y += 10/zoom) {
            let x = -a * sqrt(1 + (y*y)/(b*b));
            vertex(x, y);
        }
        endShape();
    }

    function runMode1() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        let b = sqrt(c*c - a*a);

        fill(0, 122, 255); noStroke();
        ellipse(-c, 0, 15/zoom); ellipse(c, 0, 15/zoom);
        
        drawSubText("F", "â‚", -c, -15/zoom, 16/zoom);
        drawSubText("F", "â‚‚", c, -15/zoom, 16/zoom);

        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            let penY = worldMY;
            let branch = worldMX >= 0 ? 1 : -1;
            let penX = branch * a * sqrt(1 + (penY*penY)/(b*b));
            
            tracePoints.push({x: penX, y: penY});
            
            let d1 = dist(penX, penY, -c, 0);
            let d2 = dist(penX, penY, c, 0);
            
            stroke(34, 197, 94); strokeWeight(3/zoom);
            line(-c, 0, penX, penY); line(c, 0, penX, penY);
            
            fill(100); noStroke(); ellipse(penX, penY, 10/zoom);
            fill(200, 100, 0); rect(penX - 2/zoom, penY - 15/zoom, 4/zoom, 20/zoom);

            fill(0); textSize(15/zoom); textAlign(CENTER);
            text("dâ‚: " + d1.toFixed(1), (-c + penX)/2, penY/2 - 10/zoom);
            text("dâ‚‚: " + d2.toFixed(1), (c + penX)/2, penY/2 - 10/zoom);
            
            fill(255, 59, 48); textSize(18/zoom); textStyle(BOLD);
            text("ê±°ë¦¬ì˜ ì°¨ |dâ‚ - dâ‚‚| = " + abs(d1-d2).toFixed(1) + " (ì¼ì •)", 0, -100/zoom);
            textStyle(NORMAL);
        } else {
            stroke(150, 150, 150, 100); strokeWeight(3/zoom); noFill();
            let defX = a * sqrt(1 + (60/zoom)*(60/zoom)/(b*b));
            beginShape(); vertex(-c, 0); vertex(defX, 60/zoom); vertex(c, 0); endShape();
        }

        noFill(); stroke(50, 50, 200); strokeWeight(4/zoom);
        for (let pt of tracePoints) {
            point(pt.x, pt.y);
        }
    }

    function runMode2() {
        let b = sqrt(c*c - a*a);
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        let slope = (b/a).toFixed(2);

        let distAsymp1 = abs(b * worldMX - a * worldMY) / c;
        let distAsymp2 = abs(b * worldMX + a * worldMY) / c;
        let isHoveringAsymptote = (distAsymp1 < 15/zoom || distAsymp2 < 15/zoom) && !isOverUI();

        if (isHoveringAsymptote) {
            stroke(255, 140, 0); strokeWeight(3/zoom);
        } else {
            stroke(150); strokeWeight(2/zoom);
        }
        
        drawingContext.setLineDash([8, 8]);
        line(-3000, -3000 * b/a, 3000, 3000 * b/a);
        line(-3000, 3000 * b/a, 3000, -3000 * b/a);
        drawingContext.setLineDash([]);

        // ìŒê³¡ì„  ìƒ‰ìƒì„ ëˆˆì— ë„ëŠ” íŒŒë€ìƒ‰ìœ¼ë¡œ ë³€ê²½
        drawHyperbolaLines(a, b, color(0, 122, 255), 4/zoom);

        let checkPts = [
            {x: -c, y: 0, label: "F", sub: "â‚", prefix: "ì´ˆì  ", coord: `(-${c}, 0)`},
            {x: c, y: 0, label: "F", sub: "â‚‚", prefix: "ì´ˆì  ", coord: `(${c}, 0)`}
        ];

        let hoveredPt = null;
        for (let pt of checkPts) {
            if (dist(worldMX, worldMY, pt.x, pt.y) < 25/zoom && !isOverUI()) {
                hoveredPt = pt; break;
            }
        }

        fill(0, 122, 255); noStroke(); ellipse(-c, 0, 15/zoom); ellipse(c, 0, 15/zoom);

        if (hoveredPt) {
            fill(255, 204, 0, 100); noStroke();
            ellipse(hoveredPt.x, hoveredPt.y, 35/zoom); 
            
            fill(0); textSize(15/zoom);
            textAlign(RIGHT, BASELINE); text(hoveredPt.prefix, hoveredPt.x - 10/zoom, hoveredPt.y - 20/zoom);
            drawSubText(hoveredPt.label, hoveredPt.sub, hoveredPt.x + 15/zoom, hoveredPt.y - 20/zoom, 15/zoom);
            
            textAlign(CENTER, BASELINE);
            fill(0, 100, 255); textStyle(BOLD);
            text(hoveredPt.coord, hoveredPt.x, hoveredPt.y - 42/zoom);
            textStyle(NORMAL);
        } else {
            drawSubText("F", "â‚", -c, -15/zoom, 12/zoom, 100);
            drawSubText("F", "â‚‚", c, -15/zoom, 12/zoom, 100);
        }

        if (isHoveringAsymptote && !hoveredPt) {
            fill(255, 140, 0); noStroke(); textStyle(BOLD);
            textSize(16/zoom); textAlign(CENTER, BOTTOM);
            
            let eq = (distAsymp1 < distAsymp2) ? `y = ${slope}x` : `y = -${slope}x`;
            text(`ì ê·¼ì„ : ${eq}`, worldMX, worldMY - 15/zoom);
            textStyle(NORMAL);
        }

        if (mouseIsPressed && !isOverUI() && !hoveredPt && !isHoveringAsymptote) {
            activeY = worldMY;
            activeBranch = worldMX >= 0 ? 1 : -1;
        } else if (mouseIsPressed && !isOverUI() && !hoveredPt && !isHoveringAsymptote && activeY !== null) {
             activeY = null;
             updateMathInfo();
        }

        if (activeY !== null) {
            let px = activeBranch * a * sqrt(1 + (activeY*activeY)/(b*b));
            let py = activeY;
            let d1 = dist(px, py, -c, 0); 
            let d2 = dist(px, py, c, 0);

            stroke(34, 197, 94); strokeWeight(3/zoom);
            line(-c, 0, px, py); line(c, 0, px, py);
            fill(34, 197, 94); noStroke(); ellipse(px, py, 12/zoom);
            
            fill(0); textSize(15/zoom); textAlign(CENTER); textStyle(NORMAL);
            text("dâ‚: " + d1.toFixed(1), (-c + px)/2, py/2 - 10/zoom);
            text("dâ‚‚: " + d2.toFixed(1), (c + px)/2, py/2 - 10/zoom);
            
            updateMathInfo({
                d1: d1.toFixed(1),
                d2: d2.toFixed(1),
                diff: abs(d1-d2).toFixed(1)
            });
        }
    }

    function getHyperbolaIntersection(sx, sy, dx, dy, a, b) {
        let A = (dx*dx)/(a*a) - (dy*dy)/(b*b);
        let B = 2*sx*dx/(a*a) - 2*sy*dy/(b*b);
        let C = (sx*sx)/(a*a) - (sy*sy)/(b*b) - 1;

        if (abs(A) < 1e-6) {
            if (abs(B) > 1e-6) {
                let t = -C/B;
                if (t > 1e-4) return createVector(sx + t*dx, sy + t*dy);
            }
            return null;
        }

        let det = B*B - 4*A*C;
        if (det < 0) return null; 
        
        let t1 = (-B + Math.sqrt(det)) / (2*A);
        let t2 = (-B - Math.sqrt(det)) / (2*A);
        
        let t = -1;
        if (t1 > 1e-4 && t2 > 1e-4) t = min(t1, t2);
        else if (t1 > 1e-4) t = t1;
        else if (t2 > 1e-4) t = t2;

        if (t > 0) return createVector(sx + t*dx, sy + t*dy);
        return null;
    }

    function getPosAlongPath(path, dists, d) {
        if (d <= 0) return path[0];
        let currentDist = 0;
        for (let i = 0; i < dists.length; i++) {
            if (d <= currentDist + dists[i]) {
                let t = (d - currentDist) / dists[i];
                return p5.Vector.lerp(path[i], path[i+1], t);
            }
            currentDist += dists[i];
        }
        return path[path.length - 1];
    }

    function toggleLightSource() {
        activeLightTarget = activeLightTarget === 1 ? 2 : 1;
        let subNum = activeLightTarget === 1 ? "â‚" : "â‚‚";
        document.getElementById('lightSwitchBtn').innerHTML = `ğŸ¯ íƒ€ê²Ÿ ì´ˆì  ë³€ê²½ (í˜„ì¬: F${subNum})`;
        rays = []; 
    }

    function runMode3() {
        let b = sqrt(c*c - a*a);
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        drawHyperbolaLines(a, b, color(50, 50, 200), 4/zoom);

        let targetPos = activeLightTarget === 1 ? -c : c;
        let otherPos = activeLightTarget === 1 ? c : -c;

        fill(0, 122, 255); noStroke(); ellipse(otherPos, 0, 15/zoom); 
        fill(255, 59, 48); ellipse(targetPos, 0, 15/zoom); 
        
        drawSubText("F", activeLightTarget === 1 ? "â‚" : "â‚‚", targetPos, -20/zoom, 16/zoom);
        drawSubText("F", activeLightTarget === 1 ? "â‚‚" : "â‚", otherPos, -20/zoom, 16/zoom);

        if(!isOverUI()) {
            fill(255, 215, 0); noStroke(); ellipse(worldMX, worldMY, 12/zoom);
        }

        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            if (frameCount % 8 === 0) {
                let p_start = createVector(worldMX, worldMY);
                let targetVec = createVector(targetPos, 0);
                let dir = p5.Vector.sub(targetVec, p_start).normalize();
                
                let p_hit = getHyperbolaIntersection(p_start.x, p_start.y, dir.x, dir.y, a, b);
                
                if (p_hit) {
                    let bouncePath = [p_start.copy(), p_hit.copy()];
                    
                    let nx = 2 * p_hit.x / (a*a);
                    let ny = -2 * p_hit.y / (b*b);
                    let normal = createVector(nx, ny).normalize();
                    
                    let vInc = p5.Vector.sub(p_hit, p_start).normalize();
                    if (vInc.dot(normal) > 0) normal.mult(-1);
                    
                    let vRef = p5.Vector.sub(vInc, p5.Vector.mult(normal, 2 * vInc.dot(normal)));
                    
                    let farDist = 3000;
                    bouncePath.push(createVector(p_hit.x + vRef.x * farDist, p_hit.y + vRef.y * farDist));

                    let dists = [];
                    let totalD = 0;
                    for(let i=0; i<bouncePath.length-1; i++) {
                        let d = p5.Vector.dist(bouncePath[i], bouncePath[i+1]);
                        dists.push(d); totalD += d;
                    }

                    let sumDists = [0];
                    for(let i=0; i<dists.length; i++) sumDists.push(sumDists[i] + dists[i]);

                    rays.push({ path: bouncePath, dists: dists, sumDists: sumDists, progress: 0, totalDist: totalD });
                }
            }
        }

        let speed = 35 / zoom;
        let beamLen = 150 / zoom; 
        let showAngle = document.getElementById('angleCheck').checked;

        for (let i = rays.length - 1; i >= 0; i--) {
            let r = rays[i];
            r.progress += speed;

            stroke(255, 59, 48, 50); strokeWeight(1/zoom); drawingContext.setLineDash([4, 4]);
            line(r.path[1].x, r.path[1].y, targetPos, 0);
            drawingContext.setLineDash([]);

            stroke(255, 204, 0, 30); strokeWeight(2/zoom);
            line(r.path[0].x, r.path[0].y, r.path[1].x, r.path[1].y); 

            let head = r.progress;
            let tail = max(0, r.progress - beamLen);

            noFill(); stroke(255, 220, 0); strokeWeight(6/zoom);
            beginShape();
            for (let d = tail; d <= head; d += 5/zoom) {
                let pos = getPosAlongPath(r.path, r.dists, d);
                vertex(pos.x, pos.y);
            }
            let headPos = getPosAlongPath(r.path, r.dists, head);
            vertex(headPos.x, headPos.y);
            endShape();

            noStroke(); fill(255, 255, 255, 200); ellipse(headPos.x, headPos.y, 8/zoom);

            if (showAngle && r.progress > r.sumDists[1]) {
                let px = r.path[1].x; let py = r.path[1].y;
                let nx = 2 * px / (a*a); let ny = -2 * py / (b*b);
                let vNorm = createVector(nx, ny).normalize();
                let vInc = createVector(r.path[0].x - px, r.path[0].y - py).normalize();
                if (vNorm.dot(vInc) < 0) vNorm.mult(-1);
                
                let vTan = createVector(-vNorm.y, vNorm.x);

                stroke(40, 167, 69, 150); strokeWeight(2/zoom); drawingContext.setLineDash([6, 6]);
                line(px - vTan.x*80/zoom, py - vTan.y*80/zoom, px + vTan.x*80/zoom, py + vTan.y*80/zoom);
                drawingContext.setLineDash([]);
                
                push();
                fill(40, 167, 69); noStroke(); textStyle(BOLD); textSize(14/zoom); textAlign(CENTER, CENTER);
                text("ì ‘ì„ ", px + vTan.x * 95 / zoom, py + vTan.y * 95 / zoom);
                pop();

                stroke(255, 136, 0, 180); strokeWeight(2/zoom);
                line(px, py, px + vNorm.x*60/zoom, py + vNorm.y*60/zoom);

                let vRef = createVector(r.path[2].x - px, r.path[2].y - py).normalize();
                let angleDeg = degrees(acos(vInc.dot(vNorm))).toFixed(1);

                let rArc = 35 / zoom;
                noFill(); stroke(255, 100, 0, 150); strokeWeight(2/zoom);
                let drawArc = (v1, v2) => {
                    let a1 = v1.heading(); let a2 = v2.heading();
                    let start = min(a1, a2); let stop = max(a1, a2);
                    if (stop - start > PI) { start = stop; stop = min(a1,a2) + TWO_PI; }
                    arc(px, py, rArc*2, rArc*2, start, stop);
                };
                drawArc(vNorm, vInc); drawArc(vNorm, vRef);

                fill(255, 100, 0); noStroke(); textSize(12/zoom); textAlign(CENTER, CENTER);
                let txtInc = p5.Vector.add(vInc, vNorm).normalize().mult(55/zoom);
                let txtRef = p5.Vector.add(vRef, vNorm).normalize().mult(55/zoom);
                text(angleDeg + "Â°", px + txtInc.x, py + txtInc.y);
                text(angleDeg + "Â°", px + txtRef.x, py + txtRef.y);
            }
            if (tail > 2000) rays.splice(i, 1);
        }
    }

    function setMode(m) {
        mode = m;
        activeY = null;
        document.getElementById('tab1').classList.toggle('active', m === 1);
        document.getElementById('tab2').classList.toggle('active', m === 2);
        document.getElementById('tab3').classList.toggle('active', m === 3);
        
        document.getElementById('angleUi').style.display = (m === 3) ? 'flex' : 'none';
        document.getElementById('lightSwitchBtn').style.display = (m === 3) ? 'block' : 'none';
        document.getElementById('mathBox').style.display = (m === 2) ? 'block' : 'none';
        
        updateInstruction();
        updateInfoText();
    }

    function toggleInfo() {
        isInfoOpen = !isInfoOpen;
        let btn = document.getElementById('infoToggleBtn');
        let box = document.getElementById('infoBox');
        if (isInfoOpen) { btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ë„ê¸°"; box.style.display = "block"; updateInfoText(); } 
        else { btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°"; box.style.display = "none"; }
    }

    function updateInfoText() { if (isInfoOpen) document.getElementById('infoBox').innerHTML = conceptTexts[mode]; }

    function updateInstruction() {
        let ins = document.getElementById('instructions');
        if (mode === 1) ins.innerHTML = "ë¹ˆ ê³µê°„ì„ <b>í´ë¦­í•˜ì—¬ ìœ„ì•„ë˜ë¡œ ë“œë˜ê·¸</b> í•´ë³´ì„¸ìš”. ì‹¤ì‹œê°„ìœ¼ë¡œ ê±°ë¦¬ì˜ ì°¨ì´ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.";
        else if (mode === 2) ins.innerHTML = "ì´ˆì ì´ë‚˜ <b>ì ê·¼ì„ (íšŒìƒ‰ ì ì„ )ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë ¤ë³´ì„¸ìš”.</b><br>ìŒê³¡ì„  ìœ„ë¥¼ <b>í´ë¦­</b>í•˜ë©´ ì ê³¼ ê±°ë¦¬ê°€ ê³ ì •ë©ë‹ˆë‹¤. (ë‹¤ì‹œ í´ë¦­í•˜ë©´ ê°±ì‹ )";
        else if (mode === 3) ins.innerHTML = "ë§ˆìš°ìŠ¤ë¥¼ <b>ì†ì „ë“±ì²˜ëŸ¼ ì¡°ì‘í•˜ì—¬ ë¶‰ì€ìƒ‰ íƒ€ê²Ÿ ì´ˆì ì„ í–¥í•´ í´ë¦­</b>(ë¹› ë°œì‚¬) í•´ë³´ì„¸ìš”.";
    }

    function resetData() { tracePoints = []; activeY = null; rays = []; updateMathInfo(); }
    function mouseDragged() { if (mouseButton === RIGHT) { offsetX += mouseX - pmouseX; offsetY += mouseY - pmouseY; } }
    function mouseWheel(event) { zoom = constrain(zoom - event.delta * 0.001, 0.2, 4); return false; }
    
    function isOverUI() { 
        let inLeftMenu = mouseY < 280 && mouseX < 260;
        let inRightInfo = isInfoOpen && (mouseX > width - 360 && mouseY < 400); 
        let inMathBox = mode === 2 && (mouseX < 280 && mouseY > height - 300);
        return inLeftMenu || inRightInfo || inMathBox;
    } 

    function resetView() { zoom = 1.0; offsetX = 0; offsetY = 0; }
    function drawGrid() { stroke(240); strokeWeight(1/zoom); for (let i = -2500; i < 2500; i += 50) line(i, -2500, i, 2500); for (let j = -2500; j < 2500; j += 50) line(-2500, j, 2500, j); }
    function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
