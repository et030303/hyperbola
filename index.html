<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŒê³¡ì„ ì˜ ëª¨ë“  ê²ƒ by ET</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Pretendard', sans-serif; }
        
        #header { position: absolute; top: 0; width: 100%; background: #1a1a2e; color: white; text-align: center; padding: 12px 0; font-size: 24px; font-weight: 800; z-index: 1002; letter-spacing: 1px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        #header span { color: #00d2ff; font-size: 16px; font-weight: normal; margin-left: 8px; }
        
        #menu { position: absolute; top: 52px; width: 100%; display: flex; justify-content: center; background: rgba(255, 255, 255, 0.95); box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; }
        .tab { padding: 15px 25px; cursor: pointer; border-bottom: 3px solid transparent; font-weight: bold; color: #555; transition: 0.3s; }
        .tab.active { border-bottom: 3px solid #007bff; color: #007bff; }
        
        #ui-layer { position: absolute; top: 120px; left: 20px; z-index: 1001; display: flex; flex-direction: column; gap: 10px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .ui-item { display: flex; align-items: center; gap: 8px; }
        .ui-item label { font-size: 14px; font-weight: bold; color: #333; min-width: 90px; }

        button { padding: 10px 15px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: background 0.2s; }
        button:hover { filter: brightness(1.1); }
        button.reset { background: #ff3b30; margin-top: 5px; }
        button.info { background: #17a2b8; margin-top: 5px; }
        button.switch { background: #ff9500; display: none; margin-top: 5px; color: white;} 
        
        input[type=range] { -webkit-appearance: none; width: 140px; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none; transition: .2s; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #007bff; cursor: pointer; box-shadow: 0 0 5px rgba(0,0,0,0.2); }
        
        #angleUi { display: none; align-items: center; background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 8px; font-weight: bold; font-size: 14px; color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; border: 2px solid #007bff; margin-top: 5px;}
        #angleUi input { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }

        #infoBox { display: none; position: absolute; top: 120px; right: 20px; width: 320px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border-left: 5px solid #17a2b8; font-size: 14px; line-height: 1.6; color: #333; z-index: 1001; }
        #infoBox h3 { margin-top: 0; margin-bottom: 12px; color: #17a2b8; font-size: 18px; }

        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 12px 24px; border-radius: 30px; font-size: 14px; pointer-events: none; z-index: 1001; text-align: center; line-height: 1.5; white-space: nowrap; }
    </style>
</head>
<body>

<div id="header">ìŒê³¡ì„ ì˜ ëª¨ë“  ê²ƒ<span>by ET</span></div>

<div id="menu">
    <div id="tab1" class="tab active" onclick="setMode(1)">1. ìì·¨ ì‘ë„</div>
    <div id="tab2" class="tab" onclick="setMode(2)">2. ì •ì˜ í•™ìŠµ</div>
    <div id="tab3" class="tab" onclick="setMode(3)">3. ê´‘í•™ ì„±ì§ˆ</div>
</div>

<div id="ui-layer">
    <div class="ui-item">
        <label>ì´ˆì  ê±°ë¦¬ (2c):</label>
        <input type="range" id="cSlider" min="200" max="600" value="300" step="10">
        <span id="cValue">300</span>
    </div>
    <div class="ui-item">
        <label>ê±°ë¦¬ì˜ ì°¨ (2a):</label>
        <input type="range" id="aSlider" min="50" max="400" value="160" step="10">
        <span id="aValue">160</span>
    </div>
    <button id="resetBtn" class="reset" onclick="resetData()">ë°ì´í„° ì´ˆê¸°í™”</button>
    <button onclick="resetView()">í™”ë©´ ìœ„ì¹˜ ì´ˆê¸°í™”</button>
    
    <button id="lightSwitchBtn" class="switch" onclick="toggleLightSource()">ğŸ¯ íƒ€ê²Ÿ ì´ˆì  ë³€ê²½ (í˜„ì¬: Fâ‚)</button>
    <label id="angleUi">
        <input type="checkbox" id="angleCheck"> ì…ì‚¬ê° / ë°˜ì‚¬ê° ë³´ê¸°
    </label>

    <button id="infoToggleBtn" class="info" onclick="toggleInfo()">ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°</button>
</div>

<div id="infoBox"></div>
<div id="instructions"></div>

<script>
    let mode = 1;
    let zoom = 1.0;
    let offsetX = 0, offsetY = 0;
    
    let c = 150; 
    let a = 80;  

    let tracePoints = [];
    let activeY = null;
    let activeBranch = 1;
    let rays = [];
    let activeLightTarget = 1; 

    let isInfoOpen = false;
    const conceptTexts = {
        1: "<h3>ìì·¨ ì‘ë„ ì›ë¦¬</h3>ìŒê³¡ì„ ì€ <b>ë‘ ì´ˆì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ì˜ ì°¨ê°€ ì¼ì •í•œ ì ë“¤ì˜ ì§‘í•©</b>ì…ë‹ˆë‹¤.<br><br>ë§ˆìš°ìŠ¤ë¥¼ ìœ„ì•„ë˜ë¡œ ì›€ì§ì—¬ ê¶¤ì ì„ ê·¸ë ¤ë³´ì„¸ìš”. ê·¸ë ¤ì§€ëŠ” ì ê³¼ ë‘ ì´ˆì  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•´ ë³´ë©´ ê·¸ <b>ì°¨ì´ê°€ í•­ìƒ ì¼ì •(2a)</b>í•¨ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        2: "<h3>ìŒê³¡ì„ ì˜ ì •ì˜ì™€ ì ê·¼ì„ </h3>ì–´ëŠ ìœ„ì¹˜ì— ìˆë“  <b>ë‘ ì´ˆì ê¹Œì§€ì˜ ê±°ë¦¬ì˜ ì°¨ê°€ í•­ìƒ ì¼ì •(2a)</b>í•©ë‹ˆë‹¤.<br><br>ì¤‘ì‹¬ì„ ì§€ë‚˜ëŠ” <b>íšŒìƒ‰ ì ì„ ì€ ìŒê³¡ì„ ì˜ ì ê·¼ì„ </b>ì…ë‹ˆë‹¤. ìŒê³¡ì„ ì´ ë»—ì–´ ë‚˜ê°ˆìˆ˜ë¡ ì´ ì„ ì— ë¬´í•œíˆ ê°€ê¹Œì›Œì§€ì§€ë§Œ ê²°ì½” ë§Œë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.",
        3: "<h3>ìŒê³¡ì„ ì˜ ê´‘í•™ì  ì„±ì§ˆ</h3>ì™¸ë¶€ì—ì„œ <b>í•œ ì´ˆì ì„ í–¥í•´ ë˜‘ë°”ë¡œ ìœ ë¹›</b>ì€ ìŒê³¡ì„  ë©´ì— ë¶€ë”ªíˆë©´ <b>ë°˜ëŒ€í¸ ì´ˆì ì„ í–¥í•´ ë°˜ì‚¬</b>ë©ë‹ˆë‹¤.<br><br>ë§ˆìš°ìŠ¤(ì†ì „ë“±)ë¡œ íƒ€ê²Ÿ ì´ˆì ì„ í–¥í•´ ë¹›ì„ ì´ë³´ì„¸ìš”. ê±°ìš¸ì— ë°˜ì‚¬ëœ ë¹›ì´ ì •í™•íˆ ë°˜ëŒ€í¸ ì´ˆì ìœ¼ë¡œ ëª¨ì´ê±°ë‚˜ í¼ì§€ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."
    };

    function setup() {
        createCanvas(windowWidth, windowHeight);
        document.oncontextmenu = () => false;

        let cSlider = select('#cSlider');
        let aSlider = select('#aSlider');
        let cVal = select('#cValue');
        let aVal = select('#aValue');

        cSlider.input(() => {
            c = cSlider.value() / 2;
            cVal.html(cSlider.value());
            if (cSlider.value() <= aSlider.value()) {
                aSlider.value(parseInt(cSlider.value()) - 20);
                aVal.html(aSlider.value());
                a = aSlider.value() / 2;
            }
            resetData();
        });

        aSlider.input(() => {
            if (aSlider.value() >= cSlider.value()) {
                aSlider.value(parseInt(cSlider.value()) - 20);
            }
            a = aSlider.value() / 2;
            aVal.html(aSlider.value());
            resetData();
        });

        updateInstruction();
    }

    function draw() {
        background(255);
        
        push();
        translate(width/2 + offsetX, height/2 + offsetY);
        scale(zoom);
        drawGrid();

        if (mode === 1) runMode1();
        else if (mode === 2) runMode2();
        else if (mode === 3) runMode3();
        
        pop();
    }

    function drawSubText(mainText, subText, x, y, size, col) {
        push();
        fill(col || 0); noStroke();
        textSize(size);
        let wMain = textWidth(mainText);
        textSize(size * 0.7);
        let wSub = textWidth(subText);
        let totalW = wMain + wSub;
        let startX = x - totalW / 2;
        
        textAlign(LEFT, BASELINE);
        textSize(size);
        text(mainText, startX, y);
        textSize(size * 0.7);
        text(subText, startX + wMain, y + size * 0.25);
        pop();
    }

    function drawHyperbolaLines(a, b, col, weight) {
        noFill(); stroke(col); strokeWeight(weight);
        beginShape();
        for (let y = -1000/zoom; y <= 1000/zoom; y += 10/zoom) {
            let x = a * sqrt(1 + (y*y)/(b*b));
            vertex(x, y);
        }
        endShape();
        beginShape();
        for (let y = -1000/zoom; y <= 1000/zoom; y += 10/zoom) {
            let x = -a * sqrt(1 + (y*y)/(b*b));
            vertex(x, y);
        }
        endShape();
    }

    function runMode1() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        let b = sqrt(c*c - a*a);

        fill(0, 122, 255); noStroke();
        ellipse(-c, 0, 15/zoom); ellipse(c, 0, 15/zoom);
        
        drawSubText("F", "â‚", -c, -15/zoom, 16/zoom);
        drawSubText("F", "â‚‚", c, -15/zoom, 16/zoom);

        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            let penY = worldMY;
            let branch = worldMX >= 0 ? 1 : -1;
            let penX = branch * a * sqrt(1 + (penY*penY)/(b*b));
            
            tracePoints.push({x: penX, y: penY});
            
            let d1 = dist(penX, penY, -c, 0);
            let d2 = dist(penX, penY, c, 0);
            
            stroke(34, 197, 94); strokeWeight(3/zoom);
            line(-c, 0, penX, penY); line(c, 0, penX, penY);
            
            fill(100); noStroke(); ellipse(penX, penY, 10/zoom);
            fill(200, 100, 0); rect(penX - 2/zoom, penY - 15/zoom, 4/zoom, 20/zoom);

            fill(0); textSize(15/zoom); textAlign(CENTER);
            text("dâ‚: " + d1.toFixed(1), (-c + penX)/2, penY/2 - 10/zoom);
            text("dâ‚‚: " + d2.toFixed(1), (c + penX)/2, penY/2 - 10/zoom);
            
            fill(255, 59, 48); textSize(18/zoom); textStyle(BOLD);
            text("ê±°ë¦¬ì˜ ì°¨ |dâ‚ - dâ‚‚| = " + abs(d1-d2).toFixed(1) + " (ì¼ì •)", 0, -100/zoom);
            textStyle(NORMAL);
        } else {
            stroke(150, 150, 150, 100); strokeWeight(3/zoom); noFill();
            let defX = a * sqrt(1 + (60/zoom)*(60/zoom)/(b*b));
            beginShape(); vertex(-c, 0); vertex(defX, 60/zoom); vertex(c, 0); endShape();
        }

        noFill(); stroke(50, 50, 200); strokeWeight(4/zoom);
        for (let pt of tracePoints) {
            point(pt.x, pt.y);
        }
    }

    function runMode2() {
        let b = sqrt(c*c - a*a);
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        let distAsymp1 = abs(b * worldMX - a * worldMY) / c;
        let distAsymp2 = abs(b * worldMX + a * worldMY) / c;
        let isHoveringAsymptote = (distAsymp1 < 15/zoom || distAsymp2 < 15/zoom) && !isOverUI();

        if (isHoveringAsymptote) {
            stroke(255, 140, 0); strokeWeight(3/zoom);
        } else {
            stroke(180); strokeWeight(2/zoom);
        }
        
        drawingContext.setLineDash([10, 10]);
        line(-2000, -2000 * b/a, 2000, 2000 * b/a);
        line(-2000, 2000 * b/a, 2000, -2000 * b/a);
        drawingContext.setLineDash([]);

        drawHyperbolaLines(a, b, color(180), 3/zoom);

        let checkPts = [
            {x: 0, y: 0, label: "ì¤‘ì‹¬"},
            {x: -c, y: 0, label: "F", sub: "â‚", prefix: "ì´ˆì  "},
            {x: c, y: 0, label: "F", sub: "â‚‚", prefix: "ì´ˆì  "}
        ];

        let hoveredPt = null;
        for (let pt of checkPts) {
            if (dist(worldMX, worldMY, pt.x, pt.y) < 25/zoom && !isOverUI()) {
                hoveredPt = pt; break;
            }
        }

        fill(0); noStroke(); ellipse(0, 0, 8/zoom);
        fill(0, 122, 255); ellipse(-c, 0, 15/zoom); ellipse(c, 0, 15/zoom);

        if (hoveredPt) {
            fill(255, 204, 0, 100); noStroke();
            ellipse(hoveredPt.x, hoveredPt.y, 35/zoom); 
            
            fill(0); textSize(15/zoom);
            if (hoveredPt.sub) {
                textAlign(RIGHT, BASELINE); text(hoveredPt.prefix, hoveredPt.x - 10/zoom, hoveredPt.y - 20/zoom);
                drawSubText(hoveredPt.label, hoveredPt.sub, hoveredPt.x + 15/zoom, hoveredPt.y - 20/zoom, 15/zoom);
            } else {
                textAlign(CENTER, BASELINE);
                text(hoveredPt.label, hoveredPt.x, hoveredPt.y - 18/zoom);
            }
        } else {
            drawSubText("F", "â‚", -c, -15/zoom, 12/zoom, 100);
            drawSubText("F", "â‚‚", c, -15/zoom, 12/zoom, 100);
        }

        if (isHoveringAsymptote && !hoveredPt) {
            fill(255, 140, 0); noStroke(); textStyle(BOLD);
            textSize(16/zoom); textAlign(CENTER, BOTTOM);
            text("ì ê·¼ì„ ", worldMX, worldMY - 15/zoom);
            textStyle(NORMAL);
        }

        if (mouseIsPressed && !isOverUI() && !hoveredPt && !isHoveringAsymptote) {
            activeY = worldMY;
            activeBranch = worldMX >= 0 ? 1 : -1;
        }

        if (activeY !== null && mouseIsPressed) {
            let px = activeBranch * a * sqrt(1 + (activeY*activeY)/(b*b));
            let py = activeY;
            let d1 = dist(px, py, -c, 0); 
            let d2 = dist(px, py, c, 0);

            stroke(34, 197, 94); strokeWeight(3/zoom);
            line(-c, 0, px, py); line(c, 0, px, py);
            fill(34, 197, 94); noStroke(); ellipse(px, py, 12/zoom);
            
            fill(0); textSize(15/zoom); textAlign(CENTER);
            text("dâ‚: " + d1.toFixed(1), (-c + px)/2, py/2 - 10/zoom);
            text("dâ‚‚: " + d2.toFixed(1), (c + px)/2, py/2 - 10/zoom);
            
            fill(255, 59, 48); textSize(18/zoom); textStyle(BOLD);
            text("ê±°ë¦¬ì˜ ì°¨ |dâ‚ - dâ‚‚| = " + abs(d1-d2).toFixed(1) + " (ì¼ì •)", 0, -100/zoom);
            textStyle(NORMAL);
        } else {
            activeY = null;
        }
    }

    function getHyperbolaIntersection(sx, sy, dx, dy, a, b) {
        let A = (dx*dx)/(a*a) - (dy*dy)/(b*b);
        let B = 2*sx*dx/(a*a) - 2*sy*dy/(b*b);
        let C = (sx*sx)/(a*a) - (sy*sy)/(b*b) - 1;

        if (abs(A) < 1e-6) {
            if (abs(B) > 1e-6) {
                let t = -C/B;
                if (t > 1e-4) return createVector(sx + t*dx, sy + t*dy);
            }
            return null;
        }

        let det = B*B - 4*A*C;
        if (det < 0) return null; 
        
        let t1 = (-B + Math.sqrt(det)) / (2*A);
        let t2 = (-B - Math.sqrt(det)) / (2*A);
        
        let t = -1;
        if (t1 > 1e-4 && t2 > 1e-4) t = min(t1, t2);
        else if (t1 > 1e-4) t = t1;
        else if (t2 > 1e-4) t = t2;

        if (t > 0) return createVector(sx + t*dx, sy + t*dy);
        return null;
    }

    function getPosAlongPath(path, dists, d) {
        if (d <= 0) return path[0];
        let currentDist = 0;
        for (let i = 0; i < dists.length; i++) {
            if (d <= currentDist + dists[i]) {
                let t = (d - currentDist) / dists[i];
                return p5.Vector.lerp(path[i], path[i+1], t);
            }
            currentDist += dists[i];
        }
        return path[path.length - 1];
    }

    function toggleLightSource() {
        activeLightTarget = activeLightTarget === 1 ? 2 : 1;
        let subNum = activeLightTarget === 1 ? "â‚" : "â‚‚";
        document.getElementById('lightSwitchBtn').innerHTML = `ğŸ¯ íƒ€ê²Ÿ ì´ˆì  ë³€ê²½ (í˜„ì¬: F${subNum})`;
        rays = []; 
    }

    function runMode3() {
        let b = sqrt(c*c - a*a);
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        drawHyperbolaLines(a, b, color(50, 50, 200), 4/zoom);

        let targetPos = activeLightTarget === 1 ? -c : c;
        let otherPos = activeLightTarget === 1 ? c : -c;

        fill(0, 122, 255); noStroke(); ellipse(otherPos, 0, 15/zoom); 
        fill(255, 59, 48); ellipse(targetPos, 0, 15/zoom); 
        
        drawSubText("F", activeLightTarget === 1 ? "â‚" : "â‚‚", targetPos, -20/zoom, 16/zoom);
        drawSubText("F", activeLightTarget === 1 ? "â‚‚" : "â‚", otherPos, -20/zoom, 16/zoom);

        if(!isOverUI()) {
            fill(255, 215, 0); noStroke(); ellipse(worldMX, worldMY, 12/zoom);
        }

        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            if (frameCount % 8 === 0) {
                let p_start = createVector(worldMX, worldMY);
                let targetVec = createVector(targetPos, 0);
                let dir = p5.Vector.sub(targetVec, p_start).normalize();
                
                let p_hit = getHyperbolaIntersection(p_start.x, p_start.y, dir.x, dir.y, a, b);
                
                if (p_hit) {
                    let bouncePath = [p_start.copy(), p_hit.copy()];
                    
                    let nx = 2 * p_hit.x / (a*a);
                    let ny = -2 * p_hit.y / (b*b);
                    let normal = createVector(nx, ny).normalize();
                    
                    let vInc = p5.Vector.sub(p_hit, p_start).normalize();
                    if (vInc.dot(normal) > 0) normal.mult(-1);
                    
                    let vRef = p5.Vector.sub(vInc, p5.Vector.mult(normal, 2 * vInc.dot(normal)));
                    
                    let farDist = 3000;
                    bouncePath.push(createVector(p_hit.x + vRef.x * farDist, p_hit.y + vRef.y * farDist));

                    let dists = [];
                    let totalD = 0;
                    for(let i=0; i<bouncePath.length-1; i++) {
                        let d = p5.Vector.dist(bouncePath[i], bouncePath[i+1]);
                        dists.push(d); totalD += d;
                    }

                    let sumDists = [0];
                    for(let i=0; i<dists.length; i++) sumDists.push(sumDists[i] + dists[i]);

                    rays.push({ path: bouncePath, dists: dists, sumDists: sumDists, progress: 0, totalDist: totalD });
                }
            }
        }

        let speed = 35 / zoom;
        let beamLen = 150 / zoom; 
        let showAngle = document.getElementById('angleCheck').checked;

        for (let i = rays.length - 1; i >= 0; i--) {
            let r = rays[i];
            r.progress += speed;

            stroke(255, 59, 48, 50); strokeWeight(1/zoom); drawingContext.setLineDash([4, 4]);
            line(r.path[1].x, r.path[1].y, targetPos, 0);
            drawingContext.setLineDash([]);

            stroke(255, 204, 0, 30); strokeWeight(2/zoom);
            line(r.path[0].x, r.path[0].y, r.path[1].x, r.path[1].y); 

            let head = r.progress;
            let tail = max(0, r.progress - beamLen);

            noFill(); stroke(255, 220, 0); strokeWeight(6/zoom);
            beginShape();
            for (let d = tail; d <= head; d += 5/zoom) {
                let pos = getPosAlongPath(r.path, r.dists, d);
                vertex(pos.x, pos.y);
            }
            let headPos = getPosAlongPath(r.path, r.dists, head);
            vertex(headPos.x, headPos.y);
            endShape();

            noStroke(); fill(255, 255, 255, 200); ellipse(headPos.x, headPos.y, 8/zoom);

            if (showAngle && r.progress > r.sumDists[1]) {
                let px = r.path[1].x; let py = r.path[1].y;
                let nx = 2 * px / (a*a); let ny = -2 * py / (b*b);
                let vNorm = createVector(nx, ny).normalize();
                let vInc = createVector(r.path[0].x - px, r.path[0].y - py).normalize();
                if (vNorm.dot(vInc) < 0) vNorm.mult(-1);
                
                let vTan = createVector(-vNorm.y, vNorm.x);

                // ì´ˆë¡ìƒ‰ ì ì„  (ì ‘ì„ )
                stroke(40, 167, 69, 150); strokeWeight(2/zoom); drawingContext.setLineDash([6, 6]);
                line(px - vTan.x*80/zoom, py - vTan.y*80/zoom, px + vTan.x*80/zoom, py + vTan.y*80/zoom);
                drawingContext.setLineDash([]);
                
                // --- 'ì ‘ì„ ' í…ìŠ¤íŠ¸ ì¶”ê°€ ---
                push();
                fill(40, 167, 69); noStroke(); textStyle(BOLD); textSize(14/zoom); textAlign(CENTER, CENTER);
                text("ì ‘ì„ ", px + vTan.x * 95 / zoom, py + vTan.y * 95 / zoom);
                pop();
                // -----------------------

                stroke(255, 136, 0, 180); strokeWeight(2/zoom);
                line(px, py, px + vNorm.x*60/zoom, py + vNorm.y*60/zoom);

                let vRef = createVector(r.path[2].x - px, r.path[2].y - py).normalize();
                let angleDeg = degrees(acos(vInc.dot(vNorm))).toFixed(1);

                let rArc = 35 / zoom;
                noFill(); stroke(255, 100, 0, 150); strokeWeight(2/zoom);
                let drawArc = (v1, v2) => {
                    let a1 = v1.heading(); let a2 = v2.heading();
                    let start = min(a1, a2); let stop = max(a1, a2);
                    if (stop - start > PI) { start = stop; stop = min(a1,a2) + TWO_PI; }
                    arc(px, py, rArc*2, rArc*2, start, stop);
                };
                drawArc(vNorm, vInc); drawArc(vNorm, vRef);

                fill(255, 100, 0); noStroke(); textSize(12/zoom); textAlign(CENTER, CENTER);
                let txtInc = p5.Vector.add(vInc, vNorm).normalize().mult(55/zoom);
                let txtRef = p5.Vector.add(vRef, vNorm).normalize().mult(55/zoom);
                text(angleDeg + "Â°", px + txtInc.x, py + txtInc.y);
                text(angleDeg + "Â°", px + txtRef.x, py + txtRef.y);
            }
            if (tail > 2000) rays.splice(i, 1);
        }
    }

    function setMode(m) {
        mode = m;
        document.getElementById('tab1').classList.toggle('active', m === 1);
        document.getElementById('tab2').classList.toggle('active', m === 2);
        document.getElementById('tab3').classList.toggle('active', m === 3);
        
        document.getElementById('angleUi').style.display = (m === 3) ? 'flex' : 'none';
        document.getElementById('lightSwitchBtn').style.display = (m === 3) ? 'block' : 'none';
        
        updateInstruction();
        updateInfoText();
    }

    function toggleInfo() {
        isInfoOpen = !isInfoOpen;
        let btn = document.getElementById('infoToggleBtn');
        let box = document.getElementById('infoBox');
        if (isInfoOpen) { btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ë„ê¸°"; box.style.display = "block"; updateInfoText(); } 
        else { btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°"; box.style.display = "none"; }
    }

    function updateInfoText() { if (isInfoOpen) document.getElementById('infoBox').innerHTML = conceptTexts[mode]; }

    function updateInstruction() {
        let ins = document.getElementById('instructions');
        if (mode === 1) ins.innerHTML = "ë¹ˆ ê³µê°„ì„ <b>í´ë¦­í•˜ì—¬ ìœ„ì•„ë˜ë¡œ ë“œë˜ê·¸</b> í•´ë³´ì„¸ìš”. ì‹¤ì‹œê°„ìœ¼ë¡œ ê±°ë¦¬ì˜ ì°¨ì´ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.";
        else if (mode === 2) ins.innerHTML = "ì´ˆì ì´ë‚˜ <b>ì ê·¼ì„ (íšŒìƒ‰ ì ì„ )ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë ¤ë³´ì„¸ìš”.</b><br>ìŒê³¡ì„  ìœ„ë¥¼ <b>í´ë¦­í•˜ì—¬ ë“œë˜ê·¸</b>í•˜ë©´ ê±°ë¦¬ì˜ ì°¨ê°€ ì¼ì •í•¨ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
        else if (mode === 3) ins.innerHTML = "ë§ˆìš°ìŠ¤ë¥¼ <b>ì†ì „ë“±ì²˜ëŸ¼ ì¡°ì‘í•˜ì—¬ ë¶‰ì€ìƒ‰ íƒ€ê²Ÿ ì´ˆì ì„ í–¥í•´ í´ë¦­</b>(ë¹› ë°œì‚¬) í•´ë³´ì„¸ìš”.";
    }

    function resetData() { tracePoints = []; activeY = null; rays = []; }
    function mouseDragged() { if (mouseButton === RIGHT) { offsetX += mouseX - pmouseX; offsetY += mouseY - pmouseY; } }
    function mouseWheel(event) { zoom = constrain(zoom - event.delta * 0.001, 0.2, 4); return false; }
    
    function isOverUI() { 
        let inLeftMenu = mouseY < 280 && mouseX < 260;
        let inRightInfo = isInfoOpen && (mouseX > width - 360 && mouseY < 400); 
        return inLeftMenu || inRightInfo;
    } 

    function resetView() { zoom = 1.0; offsetX = 0; offsetY = 0; }
    function drawGrid() { stroke(240); strokeWeight(1/zoom); for (let i = -2000; i < 2000; i += 50) line(i, -2000, i, 2000); for (let j = -2000; j < 2000; j += 50) line(-2000, j, 2000, j); }
    function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
