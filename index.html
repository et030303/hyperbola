<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŒê³¡ì„ ì˜ ëª¨ë“  ê²ƒ by ET</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Pretendard', sans-serif; }
        
        #header { position: absolute; top: 0; width: 100%; background: #1a1a2e; color: white; text-align: center; padding: 12px 0; font-size: 24px; font-weight: 800; z-index: 1002; letter-spacing: 1px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        #header span { color: #00d2ff; font-size: 16px; font-weight: normal; margin-left: 8px; }
        
        #menu { position: absolute; top: 52px; width: 100%; display: flex; justify-content: center; background: rgba(255, 255, 255, 0.95); box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; }
        .tab { padding: 15px 25px; cursor: pointer; border-bottom: 3px solid transparent; font-weight: bold; color: #555; transition: 0.3s; }
        .tab.active { border-bottom: 3px solid #007bff; color: #007bff; }
        
        #ui-layer { position: absolute; top: 120px; left: 20px; z-index: 1001; display: flex; flex-direction: column; gap: 10px; }
        button { padding: 10px 15px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: background 0.2s; }
        button:hover { filter: brightness(1.1); }
        button.reset { background: #ff3b30; }
        button.info { background: #17a2b8; } 
        
        #angleUi { display: none; align-items: center; background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 8px; font-weight: bold; font-size: 14px; color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; border: 2px solid #007bff; }
        #angleUi input { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }

        #infoBox { display: none; position: absolute; top: 120px; right: 20px; width: 320px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border-left: 5px solid #17a2b8; font-size: 14px; line-height: 1.6; color: #333; z-index: 1001; }
        #infoBox h3 { margin-top: 0; margin-bottom: 12px; color: #17a2b8; font-size: 18px; }

        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 12px 24px; border-radius: 30px; font-size: 14px; pointer-events: none; z-index: 1001; text-align: center; line-height: 1.5; }
    </style>
</head>
<body>

<div id="header">ìŒê³¡ì„ ì˜ ëª¨ë“  ê²ƒ<span>by ET</span></div>

<div id="menu">
    <div id="tab1" class="tab active" onclick="setMode(1)">1. ìì·¨ ì‘ë„</div>
    <div id="tab2" class="tab" onclick="setMode(2)">2. ì •ì˜ í•™ìŠµ</div>
    <div id="tab3" class="tab" onclick="setMode(3)">3. ê´‘í•™ ì„±ì§ˆ</div>
</div>

<div id="ui-layer">
    <button id="resetBtn" class="reset" onclick="resetData()">ë°ì´í„° ì´ˆê¸°í™”</button>
    <button onclick="resetView()">í™”ë©´ ìœ„ì¹˜ ì´ˆê¸°í™”</button>
    <button id="infoToggleBtn" class="info" onclick="toggleInfo()">ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°</button>
    
    <label id="angleUi">
        <input type="checkbox" id="angleCheck"> ì…ì‚¬ê° / ë°˜ì‚¬ê° ë³´ê¸°
    </label>
</div>

<div id="infoBox"></div>

<div id="instructions"></div>

<script>
    let mode = 1;
    let zoom = 1.0;
    let offsetX = 0, offsetY = 0;
    
    // ìŒê³¡ì„  ê¸°ë³¸ ë³€ìˆ˜
    let a = 100; 
    let b = 75;  
    let c = 125; // c = sqrt(a^2 + b^2)
    
    let tracePoints = [];
    let activePoint = null; 
    let rays = [];
    let isInfoOpen = false;

    // ëª¨ë“œ 1 ìì·¨ ì‘ë„ìš© ê°ë„ ë³€ìˆ˜
    let angleA = 0;

    const conceptTexts = {
        1: "<h3>ìì·¨ ì‘ë„ ì›ë¦¬</h3>ìŒê³¡ì„ ì€ ë‘ ì´ˆì ìœ¼ë¡œë¶€í„°ì˜ <b>ê±°ë¦¬ì˜ ì°¨ê°€ ì¼ì •í•œ ì ë“¤ì˜ ì§‘í•©</b>ì…ë‹ˆë‹¤.<br><br>â€¢ <b>ì´ˆì  F1</b>ì„ ì¤‘ì‹¬ìœ¼ë¡œ í•˜ëŠ” ì› ìœ„ì˜ <b>ì  A</b><br>â€¢ ë˜ ë‹¤ë¥¸ <b>ì´ˆì  F2</b>ì™€ ì  Aë¥¼ ì´ì€ ì„ ë¶„ì˜ <b>ìˆ˜ì§ì´ë“±ë¶„ì„ </b><br>â€¢ ì´ˆì  F1ê³¼ ì  Aë¥¼ ì‡ëŠ” ì§ì„ <br><br>ì´ ë‘ ì§ì„ ì´ ë§Œë‚˜ëŠ” êµì ì„ ì¶”ì í•˜ë©´, ë‘ ì´ˆì ê¹Œì§€ì˜ ê±°ë¦¬ ì°¨ê°€ ì¼ì •í•œ ìŒê³¡ì„ ì´ ê·¸ë ¤ì§‘ë‹ˆë‹¤.",
        2: "<h3>ìŒê³¡ì„ ì˜ ì •ì˜</h3>í‰ë©´ ìœ„ì˜ ë‘ ê³ ì •ëœ ì (<b>ì´ˆì </b>)ìœ¼ë¡œë¶€í„°ì˜ <b>ê±°ë¦¬ì˜ ì°¨ê°€ ì¼ì •í•œ ì ë“¤ì˜ ì§‘í•©</b>ì…ë‹ˆë‹¤.<br><br>â€¢ <b>ì´ˆì (Foci)</b> : ê¸°ì¤€ì´ ë˜ëŠ” ë‘ ì <br>â€¢ <b>ê¼­ì§“ì (Vertices)</b> : ìŒê³¡ì„ ì´ ì£¼ì¶•ê³¼ ë§Œë‚˜ëŠ” ì <br>â€¢ <b>ì£¼ì¶•(Transverse Axis)</b> : ë‘ ê¼­ì§“ì ì„ ì‡ëŠ” ì„ ë¶„ (ê±°ë¦¬ì˜ ì°¨ì™€ ë™ì¼)<br>â€¢ <b>ì ê·¼ì„ (Asymptotes)</b> : ìŒê³¡ì„ ì´ í•œì—†ì´ ê°€ê¹Œì›Œì§€ëŠ” ì§ì„ ",
        3: "<h3>ìŒê³¡ì„ ì˜ ê´‘í•™ì  ì„±ì§ˆ</h3>ìŒê³¡ì„ ì˜ í•œ ì´ˆì (F1)ì„ í–¥í•´ ë°–ì—ì„œ ë¹›ì„ ë¹„ì¶”ë©´, ìŒê³¡ì„  ë©´ì— ë°˜ì‚¬ëœ ë¹›ì€ <b>ë°˜ëŒ€ìª½ ì´ˆì (F2)ì„ í–¥í•´ êº¾ì—¬ ë‚˜ê°‘ë‹ˆë‹¤.</b><br><br>ë§ˆì¹˜ ë¹›ì´ ë°˜ëŒ€ìª½ ì´ˆì ì—ì„œ ë¿œì–´ì ¸ ë‚˜ì˜¤ëŠ” ê²ƒì²˜ëŸ¼ ë°˜ì‚¬ë˜ëŠ” ì„±ì§ˆì„ ê°€ì§€ë©°, ì´ëŠ” ì¹´ì„¸ê·¸ë ˆì¸ ë§ì›ê²½ ë“±ì—ì„œ ë Œì¦ˆì™€ ê±°ìš¸ì„ ì„¤ê³„í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤."
    };

    function setup() {
        createCanvas(windowWidth, windowHeight);
        document.oncontextmenu = () => false;
        updateInstruction();
    }

    function draw() {
        background(255);
        
        push();
        translate(width/2 + offsetX, height/2 + offsetY);
        scale(zoom);
        drawGrid();

        if (mode === 1) runMode1();
        else if (mode === 2) runMode2();
        else if (mode === 3) runMode3();
        
        pop();
    }

    // ì„ í˜• ë°©ì •ì‹ êµì  êµ¬í•˜ê¸° í—¬í¼ í•¨ìˆ˜
    function getIntersection(p1, v1, p2, v2) {
        let det = v1.x * v2.y - v1.y * v2.x;
        if (abs(det) < 0.001) return null;
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let t1 = (dx * v2.y - dy * v2.x) / det;
        return createVector(p1.x + t1 * v1.x, p1.y + t1 * v1.y);
    }

    // --- 1ë²ˆ: ìì·¨ ì‘ë„ ëª¨ë“œ ---
    function runMode1() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        let r = 2 * a; // ì›ì˜ ë°˜ì§€ë¦„ (ê±°ë¦¬ì˜ ì°¨)
        let f1 = createVector(-c, 0);
        let f2 = createVector(c, 0);

        // ì´ˆì  F1ì„ ì¤‘ì‹¬ìœ¼ë¡œ í•˜ëŠ” ì› ê·¸ë¦¬ê¸°
        noFill(); stroke(200); strokeWeight(2/zoom); drawingContext.setLineDash([5, 5]);
        ellipse(f1.x, f1.y, r * 2);
        drawingContext.setLineDash([]);

        // ë‘ ì´ˆì 
        fill(0, 122, 255); noStroke(); 
        ellipse(f1.x, f1.y, 15/zoom); ellipse(f2.x, f2.y, 15/zoom);
        fill(0); textSize(16/zoom); textAlign(CENTER);
        text("F1", f1.x, f1.y - 15/zoom); text("F2", f2.x, f2.y - 15/zoom);

        // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ ì  A ìœ„ì¹˜ ì œì–´
        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            angleA = atan2(worldMY - f1.y, worldMX - f1.x);
        }
        
        let ptA = createVector(f1.x + r * cos(angleA), f1.y + r * sin(angleA));
        
        // ì› ìœ„ì˜ ì  A
        fill(40, 167, 69); ellipse(ptA.x, ptA.y, 15/zoom);
        fill(0); text("A", ptA.x + 15/zoom, ptA.y - 10/zoom);

        // ì„ ë¶„ F1-Aì™€ ê·¸ ì—°ì¥ì„ 
        stroke(180); strokeWeight(1.5/zoom);
        let dirF1A = p5.Vector.sub(ptA, f1).normalize();
        line(f1.x - dirF1A.x * 2000, f1.y - dirF1A.y * 2000, f1.x + dirF1A.x * 2000, f1.y + dirF1A.y * 2000);

        // ì„ ë¶„ A-F2
        stroke(150, 150, 255); drawingContext.setLineDash([4, 4]);
        line(ptA.x, ptA.y, f2.x, f2.y);
        drawingContext.setLineDash([]);

        // ì„ ë¶„ A-F2ì˜ ìˆ˜ì§ì´ë“±ë¶„ì„ 
        let mid = p5.Vector.add(ptA, f2).mult(0.5);
        let dirMid = p5.Vector.sub(f2, ptA).normalize();
        let normalMid = createVector(-dirMid.y, dirMid.x); // ìˆ˜ì§ ë²¡í„°
        stroke(255, 150, 150); strokeWeight(2/zoom);
        line(mid.x - normalMid.x * 2000, mid.y - normalMid.y * 2000, mid.x + normalMid.x * 2000, mid.y + normalMid.y * 2000);

        // êµì  P ê³„ì‚°
        let ptP = getIntersection(f1, dirF1A, mid, normalMid);

        if (ptP) {
            // Pê°€ í™”ë©´ì„ ë„ˆë¬´ ë²—ì–´ë‚˜ì§€ ì•Šì„ ë•Œë§Œ ìì·¨ì— ì¶”ê°€ (ë§ˆìš°ìŠ¤ í´ë¦­ ì¤‘ì—ë§Œ ì €ì¥)
            if (mouseIsPressed && mouseButton === LEFT && !isOverUI() && ptP.mag() < 3000) {
                tracePoints.push(ptP.copy());
            }

            // ê±°ë¦¬ í‘œì‹œì„ 
            stroke(34, 197, 94); strokeWeight(2/zoom); line(ptP.x, ptP.y, f1.x, f1.y); // ë…¹ìƒ‰ ì„  (P-F1)
            stroke(255, 100, 100); strokeWeight(2/zoom); line(ptP.x, ptP.y, f2.x, f2.y); // ë¶‰ì€ ì„  (P-F2)

            // êµì  P ê·¸ë¦¬ê¸°
            fill(255, 59, 48); noStroke(); ellipse(ptP.x, ptP.y, 12/zoom);
            fill(0); text("P", ptP.x + 15/zoom, ptP.y);

            // ê±°ë¦¬ ì •ë³´ í…ìŠ¤íŠ¸
            let d1 = p5.Vector.dist(ptP, f1);
            let d2 = p5.Vector.dist(ptP, f2);
            let diff = abs(d1 - d2);
            fill(0); textSize(14/zoom);
            text(`|PF1 - PF2| = |${d1.toFixed(1)} - ${d2.toFixed(1)}| = ${diff.toFixed(1)}`, 0, -height/2/zoom + 50/zoom);
        }

        // ì¶”ì ëœ ìì·¨ ê·¸ë¦¬ê¸°
        noFill(); stroke(100, 100, 100, 150); strokeWeight(4/zoom);
        beginShape();
        for (let p of tracePoints) vertex(p.x, p.y);
        endShape();
    }

    function checkHoveredTermHyperbola(wx, wy) {
        if (dist(wx, wy, c, 0) < 30/zoom || dist(wx, wy, -c, 0) < 30/zoom) return "focus";
        if (dist(wx, wy, a, 0) < 30/zoom || dist(wx, wy, -a, 0) < 30/zoom) return "vertex";
        if (dist(wx, wy, 0, 0) < 30/zoom) return "center";
        
        let m = b / a;
        // ì ê·¼ì„  1: y = mx -> mx - y = 0
        let distAsymp1 = abs(m * wx - wy) / sqrt(m*m + 1);
        // ì ê·¼ì„  2: y = -mx -> mx + y = 0
        let distAsymp2 = abs(m * wx + wy) / sqrt(m*m + 1);
        if (distAsymp1 < 20/zoom || distAsymp2 < 20/zoom) return "asymptote";

        if (abs(wy) < 20/zoom && abs(wx) <= a) return "transverse"; // ì£¼ì¶•
        
        return null;
    }

    // --- 2ë²ˆ: ì •ì˜ í•™ìŠµ ëª¨ë“œ ---
    function runMode2() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        // X, Yì¶• ê·¸ë¦¬ê¸°
        stroke(200); strokeWeight(1/zoom); 
        line(-3000, 0, 3000, 0); line(0, -3000, 0, 3000);

        // ìŒê³¡ì„  ê·¸ë¦¬ê¸° (x = a*sec(t), y = b*tan(t))
        noFill(); stroke(0); strokeWeight(3/zoom);
        beginShape(); // ì˜¤ë¥¸ìª½ ê°€ì§€
        for (let t = -PI/2 + 0.1; t < PI/2 - 0.1; t += 0.05) vertex(a / cos(t), b * tan(t));
        endShape();
        beginShape(); // ì™¼ìª½ ê°€ì§€
        for (let t = PI/2 + 0.1; t < 3*PI/2 - 0.1; t += 0.05) vertex(a / cos(t), b * tan(t));
        endShape();

        let hoveredTerm = checkHoveredTermHyperbola(worldMX, worldMY);

        // í˜¸ë²„ í•˜ì´ë¼ì´íŠ¸
        if (!isOverUI() && hoveredTerm) {
            if (hoveredTerm === "focus") {
                fill(255, 204, 0, 100); noStroke(); ellipse(c, 0, 40/zoom); ellipse(-c, 0, 40/zoom);
                fill(0); textSize(16/zoom); textAlign(CENTER); text("ì´ˆì ", c, -25/zoom); text("ì´ˆì ", -c, -25/zoom);
            } else if (hoveredTerm === "vertex") {
                fill(255, 204, 0, 100); noStroke(); ellipse(a, 0, 40/zoom); ellipse(-a, 0, 40/zoom);
                fill(0); textSize(16/zoom); textAlign(CENTER); text("ê¼­ì§“ì ", a, -25/zoom); text("ê¼­ì§“ì ", -a, -25/zoom);
            } else if (hoveredTerm === "center") {
                fill(255, 204, 0, 100); noStroke(); ellipse(0, 0, 40/zoom);
                fill(0); textSize(16/zoom); textAlign(CENTER); text("ì¤‘ì‹¬", 0, -25/zoom);
            } else if (hoveredTerm === "asymptote") {
                stroke(255, 204, 0, 100); strokeWeight(15/zoom); 
                line(-3000, -3000*(b/a), 3000, 3000*(b/a)); line(-3000, 3000*(b/a), 3000, -3000*(b/a));
                fill(0); noStroke(); textSize(16/zoom); textAlign(CENTER); text("ì ê·¼ì„ ", worldMX, worldMY - 20/zoom);
            } else if (hoveredTerm === "transverse") {
                stroke(255, 204, 0, 100); strokeWeight(15/zoom); line(-a, 0, a, 0);
                fill(0); noStroke(); textSize(16/zoom); textAlign(CENTER); text("ì£¼ì¶• (ê¸¸ì´: 2a)", 0, -20/zoom);
            }
        }

        // ê¸°ë³¸ ì ë“¤ ê·¸ë¦¬ê¸°
        fill(0, 122, 255); noStroke(); ellipse(c, 0, 12/zoom); ellipse(-c, 0, 12/zoom); // ì´ˆì 
        fill(255, 59, 48); ellipse(a, 0, 10/zoom); ellipse(-a, 0, 10/zoom); // ê¼­ì§“ì 
        
        // ì ê·¼ì„  ì ì„  ê·¸ë¦¬ê¸°
        stroke(180); strokeWeight(1.5/zoom); drawingContext.setLineDash([5, 5]);
        line(-2000, -2000*(b/a), 2000, 2000*(b/a));
        line(-2000, 2000*(b/a), 2000, -2000*(b/a));
        drawingContext.setLineDash([]);

        // ìŒê³¡ì„  ìœ„ì˜ ì  í´ë¦­/ë“œë˜ê·¸ ì‹œ ê±°ë¦¬ ì •ë³´ í‘œì‹œ
        let hx = null, hy = null;
        if (mouseIsPressed && mouseButton === LEFT && !isOverUI() && !hoveredTerm) {
            // ë§ˆìš°ìŠ¤ Yì¢Œí‘œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìŒê³¡ì„  X ì¢Œí‘œ ê³„ì‚°
            hy = worldMY;
            let val = a * sqrt(1 + pow(hy, 2) / pow(b, 2));
            hx = worldMX > 0 ? val : -val; // ë§ˆìš°ìŠ¤ Xìœ„ì¹˜ì— ë”°ë¼ ì˜¤ë¥¸ìª½/ì™¼ìª½ ê°€ì§€ ì„ íƒ
            activePoint = {x: hx, y: hy};
        } else if (activePoint) {
            hx = activePoint.x; hy = activePoint.y;
        }

        if (hx !== null) {
            let pt = createVector(hx, hy);
            let f1 = createVector(-c, 0); let f2 = createVector(c, 0);
            
            stroke(34, 197, 94); strokeWeight(3/zoom); line(pt.x, pt.y, f1.x, f1.y);
            stroke(255, 100, 100); strokeWeight(3/zoom); line(pt.x, pt.y, f2.x, f2.y);
            
            fill(0); noStroke(); ellipse(pt.x, pt.y, 12/zoom);
            
            let d1 = p5.Vector.dist(pt, f1); let d2 = p5.Vector.dist(pt, f2);
            textSize(14/zoom); textAlign(CENTER);
            fill(34, 197, 94); text(d1.toFixed(1), (pt.x + f1.x)/2, (pt.y + f1.y)/2 - 10/zoom);
            fill(255, 100, 100); text(d2.toFixed(1), (pt.x + f2.x)/2, (pt.y + f2.y)/2 - 10/zoom);
            
            fill(0); textSize(16/zoom);
            text(`ê±°ë¦¬ì˜ ì°¨: |${d1.toFixed(1)} - ${d2.toFixed(1)}| = ${abs(d1 - d2).toFixed(1)} (2a = ${2*a})`, 0, -height/2/zoom + 50/zoom);
        }
    }

    // --- 3ë²ˆ: ê´‘í•™ ì„±ì§ˆ ëª¨ë“œ ---
    function runMode3() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        // ìŒê³¡ì„  ê°€ì§€ ê·¸ë¦¬ê¸°
        noFill(); stroke(50, 50, 200); strokeWeight(4/zoom);
        beginShape(); for (let t = -1.4; t < 1.4; t += 0.05) vertex(a / cos(t), b * tan(t)); endShape();
        beginShape(); for (let t = -1.4; t < 1.4; t += 0.05) vertex(-a / cos(t), b * tan(t)); endShape();

        // ì´ˆì  ê·¸ë¦¬ê¸°
        fill(0, 122, 255); noStroke(); ellipse(c, 0, 15/zoom); ellipse(-c, 0, 15/zoom);
        fill(0); textSize(16/zoom); textAlign(CENTER); text("F2", c, -20/zoom); text("F1", -c, -20/zoom);

        // ë¹› ë°œì‚¬ ë¡œì§: ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì—ì„œ ì´ˆì  F1ì„ í–¥í•´ ìœ ë¹›
        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            if (frameCount % 10 === 0) {
                // ë°œì‚¬ì (ë§ˆìš°ìŠ¤)
                let startPt = createVector(worldMX, worldMY);
                let targetF1 = createVector(-c, 0);
                
                // ë¹›ì˜ ë°©í–¥ (ë§ˆìš°ìŠ¤ -> F1)
                let dir = p5.Vector.sub(targetF1, startPt).normalize();
                
                // ìŒê³¡ì„ ê³¼ì˜ êµì  ê³„ì‚° (ì´ì°¨ë°©ì •ì‹ ê·¼ì˜ ê³µì‹ ì ìš©)
                // (X+k*dx)^2 / a^2 - (Y+k*dy)^2 / b^2 = 1
                let Aq = pow(dir.x / a, 2) - pow(dir.y / b, 2);
                let Bq = 2 * (startPt.x * dir.x / pow(a, 2) - startPt.y * dir.y / pow(b, 2));
                let Cq = pow(startPt.x / a, 2) - pow(startPt.y / b, 2) - 1;
                
                let discriminant = Bq*Bq - 4*Aq*Cq;
                
                if (discriminant >= 0) {
                    let k1 = (-Bq + sqrt(discriminant)) / (2 * Aq);
                    let k2 = (-Bq - sqrt(discriminant)) / (2 * Aq);
                    
                    // ë¹›ì´ ì§„í–‰í•˜ëŠ” ë°©í–¥(k>0) ì¤‘ ê°€ì¥ ë¨¼ì € ë¶€ë”ªíˆëŠ” ì  ì°¾ê¸°
                    let k = Infinity;
                    if (k1 > 10 && k1 < k) k = k1; // ë„ˆë¬´ ê°€ê¹Œìš´ ì  ì œì™¸
                    if (k2 > 10 && k2 < k) k = k2;

                    if (k !== Infinity) {
                        let hitPt = createVector(startPt.x + k * dir.x, startPt.y + k * dir.y);
                        
                        // ë°˜ì‚¬ ë°©í–¥ ê³„ì‚°: ìŒê³¡ì„ ì˜ ì„±ì§ˆì— ë”°ë¼, F1ì„ í–¥í•˜ë˜ ë¹›ì€ ë°˜ì‚¬ë˜ì–´ F2ë¥¼ í–¥í•¨
                        let reflectDir = p5.Vector.sub(createVector(c, 0), hitPt).normalize();
                        let endPt = p5.Vector.add(hitPt, p5.Vector.mult(reflectDir, 3000));

                        let pts = [startPt, hitPt, endPt];
                        let dists = [p5.Vector.dist(pts[0], pts[1]), p5.Vector.dist(pts[1], pts[2])];
                        let totalDist = dists[0] + dists[1];
                        
                        rays.push({ path: pts, dists: dists, totalDist: totalDist, progress: 0 });
                    }
                }
            }
            
            // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ì— ë ˆì´ì € í¬ì¸í„° ì•„ì´ì½˜
            fill(100); noStroke(); ellipse(worldMX, worldMY, 20/zoom);
            fill(255, 200, 0); ellipse(worldMX, worldMY, 10/zoom);
        }

        // ë¹› ì• ë‹ˆë©”ì´ì…˜ ë Œë”ë§
        let speed = 30 / zoom;
        let beamLen = 150 / zoom; 

        for (let i = rays.length - 1; i >= 0; i--) {
            let r = rays[i];
            r.progress += speed;

            // ê¶¤ì  í¬ë¯¸í•˜ê²Œ ê·¸ë¦¬ê¸°
            stroke(255, 204, 0, 40); strokeWeight(2/zoom);
            line(r.path[0].x, r.path[0].y, r.path[1].x, r.path[1].y);
            line(r.path[1].x, r.path[1].y, r.path[2].x, r.path[2].y);

            let head = r.progress;
            let tail = max(0, r.progress - beamLen);

            // ë¹›ë‚˜ëŠ” ë¶€ë¶„ ê·¸ë¦¬ê¸°
            noFill(); stroke(255, 220, 0); strokeWeight(6/zoom);
            beginShape();
            for (let d = tail; d <= head; d += 10/zoom) {
                let pos = getPosAlongPath(r.path, r.dists, d);
                vertex(pos.x, pos.y);
            }
            let headPos = getPosAlongPath(r.path, r.dists, head);
            vertex(headPos.x, headPos.y);
            endShape();

            noStroke(); fill(255, 255, 255, 200); ellipse(headPos.x, headPos.y, 8/zoom);

            if (tail > r.totalDist) rays.splice(i, 1);
        }

        // ê°ë„ UI ë Œë”ë§
        if (document.getElementById('angleCheck').checked) {
            for (let i = rays.length - 1; i >= 0; i--) {
                let r = rays[i];
                if (r.progress > r.dists[0] && r.progress < r.dists[0] + 500) { 
                    let hx = r.path[1].x; let hy = r.path[1].y;
                    
                    // ìŒê³¡ì„ ì˜ ë²•ì„  ë²¡í„° N = (x/a^2, -y/b^2)
                    let normalVec = createVector(hx / pow(a, 2), -hy / pow(b, 2)).normalize();
                    // ì•ˆìª½(ë¹›ì´ ë¶€ë”ªíˆëŠ” ìª½)ì„ í–¥í•˜ë„ë¡ ë°©í–¥ ì¡°ì •
                    if (normalVec.dot(p5.Vector.sub(r.path[0], r.path[1])) < 0) normalVec.mult(-1);

                    let tangentVec = createVector(-normalVec.y, normalVec.x);

                    // ì ‘ì„  ê·¸ë¦¬ê¸°
                    stroke(40, 167, 69, 180); strokeWeight(2/zoom); drawingContext.setLineDash([6, 6]);
                    line(hx - tangentVec.x*100/zoom, hy - tangentVec.y*100/zoom, hx + tangentVec.x*100/zoom, hy + tangentVec.y*100/zoom);
                    drawingContext.setLineDash([]);
                    fill(40, 167, 69); noStroke(); textSize(14/zoom); 
                    text("ì ‘ì„ ", hx + tangentVec.x*110/zoom, hy + tangentVec.y*110/zoom);

                    // ë²•ì„  ê·¸ë¦¬ê¸°
                    stroke(255, 136, 0, 220); strokeWeight(2/zoom);
                    line(hx, hy, hx + normalVec.x*80/zoom, hy + normalVec.y*80/zoom);

                    // ê°ë„ ê³„ì‚° ë° ê·¸ë¦¬ê¸°
                    let vInc = p5.Vector.sub(r.path[0], r.path[1]).normalize(); // ë“¤ì–´ì˜¤ëŠ” ë¹› (ì—­ë°©í–¥)
                    let vRef = p5.Vector.sub(r.path[2], r.path[1]).normalize(); // ë‚˜ê°€ëŠ” ë¹›
                    
                    let angleRad = acos(constrain(vInc.dot(normalVec), -1, 1)); 
                    let angleDeg = degrees(angleRad).toFixed(1);

                    let angNorm = normalVec.heading();
                    let angInc = vInc.heading();
                    let angRef = vRef.heading();

                    let rArc = 40 / zoom;
                    noFill(); stroke(255, 100, 0, 180); strokeWeight(2/zoom);
                    
                    let drawArc = (a1, a2) => {
                        let start = min(a1, a2); let stop = max(a1, a2);
                        if (stop - start > PI) { let temp = start; start = stop; stop = temp + TWO_PI; }
                        arc(hx, hy, rArc*2, rArc*2, start, stop);
                    };

                    drawArc(angNorm, angInc); drawArc(angNorm, angRef);

                    // ê°ë„ í…ìŠ¤íŠ¸ ì¶œë ¥
                    fill(255, 100, 0); noStroke(); textSize(14/zoom); textAlign(CENTER, CENTER);
                    let txtIncPos = p5.Vector.add(vInc, normalVec).normalize().mult(65/zoom);
                    let txtRefPos = p5.Vector.add(vRef, normalVec).normalize().mult(65/zoom);
                    
                    text("ì…ì‚¬ê°\n" + angleDeg + "Â°", hx + txtIncPos.x, hy + txtIncPos.y);
                    text("ë°˜ì‚¬ê°\n" + angleDeg + "Â°", hx + txtRefPos.x, hy + txtRefPos.y);
                    
                    break; // í•œ ê°œì˜ ë¹”ë§Œ í‘œì‹œ
                }
            }
        }
    }

    function getPosAlongPath(path, dists, d) {
        if (d <= 0) return path[0];
        let currentDist = 0;
        for (let i = 0; i < dists.length; i++) {
            if (d <= currentDist + dists[i]) {
                let t = (d - currentDist) / dists[i];
                return p5.Vector.lerp(path[i], path[i+1], t);
            }
            currentDist += dists[i];
        }
        return path[path.length - 1];
    }

    function mouseReleased() { activePoint = null; }

    function setMode(m) {
        mode = m;
        document.getElementById('tab1').classList.toggle('active', m === 1);
        document.getElementById('tab2').classList.toggle('active', m === 2);
        document.getElementById('tab3').classList.toggle('active', m === 3);
        
        document.getElementById('angleUi').style.display = (m === 3) ? 'flex' : 'none';
        
        updateInstruction();
        updateInfoText(); 
    }

    function toggleInfo() {
        isInfoOpen = !isInfoOpen;
        let btn = document.getElementById('infoToggleBtn');
        let box = document.getElementById('infoBox');
        
        if (isInfoOpen) {
            btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ë„ê¸°"; box.style.display = "block"; updateInfoText();
        } else {
            btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°"; box.style.display = "none";
        }
    }

    function updateInfoText() {
        if (isInfoOpen) document.getElementById('infoBox').innerHTML = conceptTexts[mode];
    }

    function updateInstruction() {
        let ins = document.getElementById('instructions');
        if (mode === 1) {
            ins.innerHTML = "íœ : í™•ëŒ€/ì¶•ì†Œ | ìš°í´ë¦­ ë“œë˜ê·¸: ì´ë™<br><b>ë¹ˆ ê³µê°„ì„ í´ë¦­/ë“œë˜ê·¸</b>í•˜ì—¬ ì  Aë¥¼ ì› ìœ„ì—ì„œ ì›€ì§ì—¬ë³´ì„¸ìš”.";
        } else if (mode === 2) {
            ins.innerHTML = "ìŒê³¡ì„  ìœ„ë¥¼ í´ë¦­í•˜ë©´ <b>ê¸¸ì´ ì •ë³´</b>ê°€ í‘œì‹œë©ë‹ˆë‹¤.<br>ì´ˆì , ê¼­ì§“ì , ì¤‘ì‹¬, ì£¼ì¶•, ì ê·¼ì„  ê·¼ì²˜ì— <b>ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë ¤ë³´ì„¸ìš”.</b>";
        } else if (mode === 3) {
            ins.innerHTML = "ë¹ˆ ê³µê°„ì„ <b>ê¾¹ ëˆ„ë¥´ê³  ìˆì–´ë³´ì„¸ìš”.</b> ë¹›ì´ ë°˜ì‚¬ë˜ì–´ ë°˜ëŒ€í¸ ì´ˆì ìœ¼ë¡œ í–¥í•©ë‹ˆë‹¤.<br><b>'ì…ì‚¬ê°/ë°˜ì‚¬ê° ë³´ê¸°'</b>ë¥¼ ì²´í¬í•˜ë©´ ë¶€ë”ªíˆëŠ” ìˆœê°„ ê°ë„ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.";
        }
    }

    function resetData() { tracePoints = []; activePoint = null; rays = []; document.getElementById('angleCheck').checked = false; angleA = 0; }
    function mouseDragged() { if (mouseButton === RIGHT) { offsetX += mouseX - pmouseX; offsetY += mouseY - pmouseY; } }
    function mouseWheel(event) { zoom = constrain(zoom - event.delta * 0.001, 0.2, 4); return false; }
    
    function isOverUI() { 
        let inLeftMenu = mouseY < 110 || (mouseX < 220 && mouseY < 280);
        let inRightInfo = isInfoOpen && (mouseX > width - 360 && mouseY < 400); 
        return inLeftMenu || inRightInfo;
    } 

    function resetView() { zoom = 1.0; offsetX = 0; offsetY = 0; }
    function drawGrid() {
        stroke(240); strokeWeight(1/zoom);
        for (let i = -2000; i < 2000; i += 50) line(i, -2000, i, 2000);
        for (let j = -2000; j < 2000; j += 50) line(-2000, j, 2000, j);
    }
    function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
