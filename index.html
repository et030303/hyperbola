<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŒê³¡ì„ ì˜ ëª¨ë“  ê²ƒ by ET</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Pretendard', sans-serif; }
        #header { position: absolute; top: 0; width: 100%; background: #1a1a2e; color: white; text-align: center; padding: 12px 0; font-size: 24px; font-weight: 800; z-index: 1002; letter-spacing: 1px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        #header span { color: #00d2ff; font-size: 16px; font-weight: normal; margin-left: 8px; }
        #menu { position: absolute; top: 52px; width: 100%; display: flex; justify-content: center; background: rgba(255, 255, 255, 0.95); box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; }
        .tab { padding: 15px 25px; cursor: pointer; border-bottom: 3px solid transparent; font-weight: bold; color: #555; transition: 0.3s; }
        .tab.active { border-bottom: 3px solid #007bff; color: #007bff; }
        #ui-layer { position: absolute; top: 120px; left: 20px; z-index: 1001; display: flex; flex-direction: column; gap: 10px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 10px; }
        button { padding: 10px 15px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button.reset { background: #ff3b30; }
        button.info { background: #17a2b8; }
        button.switch { background: #ff9500; display: none; }
        #angleUi { display: none; align-items: center; background: white; padding: 8px; border-radius: 8px; font-size: 14px; border: 1px solid #ddd; }
        #infoBox { display: none; position: absolute; top: 120px; right: 20px; width: 320px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border-left: 5px solid #17a2b8; font-size: 14px; line-height: 1.6; z-index: 1001; }
        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 12px 24px; border-radius: 30px; font-size: 14px; text-align: center; z-index: 1001; }
    </style>
</head>
<body>

<div id="header">ìŒê³¡ì„ ì˜ ëª¨ë“  ê²ƒ<span>by ET</span></div>

<div id="menu">
    <div id="tab1" class="tab active" onclick="setMode(1)">1. ìì·¨ ì‘ë„</div>
    <div id="tab2" class="tab" onclick="setMode(2)">2. ì •ì˜ í•™ìŠµ</div>
    <div id="tab3" class="tab" onclick="setMode(3)">3. ê´‘í•™ ì„±ì§ˆ</div>
</div>

<div id="ui-layer">
    <button id="resetBtn" class="reset" onclick="resetData()">ë°ì´í„° ì´ˆê¸°í™”</button>
    <button onclick="resetView()">í™”ë©´ ìœ„ì¹˜ ì´ˆê¸°í™”</button>
    <button id="lightSwitchBtn" class="switch" onclick="toggleLightSource()">ğŸ’¡ ê´‘ì› ë°©í–¥ ë³€ê²½ (í˜„ì¬: Fâ‚)</button>
    <label id="angleUi"><input type="checkbox" id="angleCheck"> ì…ì‚¬ê° / ë°˜ì‚¬ê° ë³´ê¸°</label>
    <button id="infoToggleBtn" class="info" onclick="toggleInfo()">ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°</button>
</div>

<div id="infoBox"></div>
<div id="instructions"></div>

<script>
    let mode = 1, zoom = 1.0, offsetX = 0, offsetY = 0;
    let a = 100, b = 75, c = 125;
    let tracePoints = [], activePoint = null, rays = [];
    let activeLightSource = 1; // 1: F1 ë°©í–¥, 2: F2 ë°©í–¥
    let isInfoOpen = false, angleA = 0;

    const conceptTexts = {
        1: "<h3>ìì·¨ ì‘ë„ ì›ë¦¬</h3>ìŒê³¡ì„ ì€ ë‘ ì´ˆì ìœ¼ë¡œë¶€í„°ì˜ <b>ê±°ë¦¬ì˜ ì°¨ê°€ ì¼ì •í•œ ì ë“¤ì˜ ì§‘í•©</b>ì…ë‹ˆë‹¤.<br><br>â€¢ <b>ì´ˆì  Fâ‚</b>ì„ ì¤‘ì‹¬ìœ¼ë¡œ í•˜ëŠ” ì› ìœ„ì˜ <b>ì  A</b><br>â€¢ ë˜ ë‹¤ë¥¸ <b>ì´ˆì  Fâ‚‚</b>ì™€ ì  Aë¥¼ ì´ì€ ì„ ë¶„ì˜ <b>ìˆ˜ì§ì´ë“±ë¶„ì„ </b><br>â€¢ ì§ì„  Fâ‚Aì™€ ìˆ˜ì§ì´ë“±ë¶„ì„ ì˜ êµì  P",
        2: "<h3>ìŒê³¡ì„ ì˜ ì •ì˜</h3>í‰ë©´ ìœ„ì˜ ë‘ ì´ˆì ìœ¼ë¡œë¶€í„°ì˜ <b>ê±°ë¦¬ì˜ ì°¨ê°€ ì¼ì •(2a)</b>í•œ ì ë“¤ì˜ ì§‘í•©ì…ë‹ˆë‹¤.<br><br>ìŒê³¡ì„  ìœ„ë¥¼ í´ë¦­í•˜ë©´ í•´ë‹¹ ì ì—ì„œì˜ <b>ê±°ë¦¬ ì°¨($|dâ‚ - dâ‚‚|$)</b>ê°€ í•­ìƒ ì¼ì •í•¨ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        3: "<h3>ìŒê³¡ì„ ì˜ ê´‘í•™ì  ì„±ì§ˆ</h3>í•œ ì´ˆì ($Fâ‚$)ì„ í–¥í•´ ì…ì‚¬í•œ ë¹›ì€ ìŒê³¡ì„  ê±°ìš¸ì— ë°˜ì‚¬ë˜ì–´ <b>ë‹¤ë¥¸ ìª½ ì´ˆì ($Fâ‚‚$)</b>ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤.<br><br>ì´ ì„±ì§ˆì€ ë§ì›ê²½ì˜ ë¶€ê²½ ì„¤ê³„ ë“±ì— ë§¤ìš° ì¤‘ìš”í•˜ê²Œ ì‚¬ìš©ë©ë‹ˆë‹¤."
    };

    function setup() {
        createCanvas(windowWidth, windowHeight);
        document.oncontextmenu = () => false;
        updateInstruction();
    }

    function draw() {
        background(255);
        push();
        translate(width/2 + offsetX, height/2 + offsetY);
        scale(zoom);
        drawGrid();

        if (mode === 1) runMode1();
        else if (mode === 2) runMode2();
        else if (mode === 3) runMode3();
        pop();
    }

    function drawSubText(main, sub, x, y, size, col) {
        push();
        fill(col || 0); noStroke(); textAlign(LEFT, BASELINE);
        textSize(size);
        let mw = textWidth(main);
        text(main, x - mw/2, y);
        textSize(size * 0.7);
        text(sub, x + mw/2, y + size * 0.2);
        pop();
    }

    function runMode1() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        let r = 2 * a;
        let f1 = createVector(-c, 0), f2 = createVector(c, 0);

        noFill(); stroke(200); drawingContext.setLineDash([5, 5]);
        ellipse(f1.x, f1.y, r * 2);
        drawingContext.setLineDash([]);

        drawSubText("F", "â‚", f1.x, f1.y - 15/zoom, 16/zoom, color(0, 122, 255));
        drawSubText("F", "â‚‚", f2.x, f2.y - 15/zoom, 16/zoom, color(0, 122, 255));
        fill(0, 122, 255); ellipse(f1.x, f1.y, 10/zoom); ellipse(f2.x, f2.y, 10/zoom);

        if (mouseIsPressed && !isOverUI()) angleA = atan2(worldMY - f1.y, worldMX - f1.x);
        
        let ptA = createVector(f1.x + r * cos(angleA), f1.y + r * sin(angleA));
        fill(40, 167, 69); ellipse(ptA.x, ptA.y, 10/zoom);

        let dirF1A = p5.Vector.sub(ptA, f1).normalize();
        let mid = p5.Vector.add(ptA, f2).mult(0.5);
        let normalMid = createVector(-(f2.y - ptA.y), f2.x - ptA.x).normalize();
        
        let ptP = getIntersection(f1, dirF1A, mid, normalMid);
        if (ptP) {
            if (mouseIsPressed && !isOverUI()) tracePoints.push(ptP.copy());
            stroke(34, 197, 94); line(ptP.x, ptP.y, f1.x, f1.y);
            stroke(255, 100, 100); line(ptP.x, ptP.y, f2.x, f2.y);
            fill(255, 59, 48); ellipse(ptP.x, ptP.y, 10/zoom);
        }

        noFill(); stroke(100, 150); strokeWeight(2/zoom);
        beginShape(); for (let p of tracePoints) vertex(p.x, p.y); endShape();
    }

    function runMode2() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        stroke(200); line(-width, 0, width, 0); line(0, -height, 0, height);
        
        noFill(); stroke(0); strokeWeight(2/zoom);
        beginShape(); for (let t = -1.3; t < 1.3; t += 0.05) vertex(a / cos(t), b * tan(t)); endShape();
        beginShape(); for (let t = -1.3; t < 1.3; t += 0.05) vertex(-a / cos(t), b * tan(t)); endShape();

        drawSubText("F", "â‚", -c, -15/zoom, 16/zoom, color(0, 122, 255));
        drawSubText("F", "â‚‚", c, -15/zoom, 16/zoom, color(0, 122, 255));
        fill(0, 122, 255); ellipse(-c, 0, 10/zoom); ellipse(c, 0, 10/zoom);

        if (mouseIsPressed && !isOverUI()) {
            let hx, hy = worldMY;
            let val = a * sqrt(1 + pow(hy, 2) / pow(b, 2));
            hx = worldMX > 0 ? val : -val;
            activePoint = createVector(hx, hy);
        }

        if (activePoint) {
            let d1 = dist(activePoint.x, activePoint.y, -c, 0);
            let d2 = dist(activePoint.x, activePoint.y, c, 0);
            stroke(34, 197, 94); line(activePoint.x, activePoint.y, -c, 0);
            stroke(255, 100, 100); line(activePoint.x, activePoint.y, c, 0);
            fill(0); ellipse(activePoint.x, activePoint.y, 10/zoom);

            fill(0); textSize(18/zoom); textAlign(CENTER);
            let diff = abs(d1 - d2).toFixed(1);
            text(`|dâ‚ - dâ‚‚| = |${d1.toFixed(1)} - ${d2.toFixed(1)}| = ${diff}`, 0, -height/2/zoom + 60/zoom);
        }
    }

    function toggleLightSource() {
        activeLightSource = activeLightSource === 1 ? 2 : 1;
        let subNum = activeLightSource === 1 ? "â‚" : "â‚‚";
        document.getElementById('lightSwitchBtn').innerHTML = `ğŸ’¡ ê´‘ì› ë°©í–¥ ë³€ê²½ (í˜„ì¬: F${subNum})`;
        rays = [];
    }

    function runMode3() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        
        noFill(); stroke(50, 50, 200); strokeWeight(3/zoom);
        beginShape(); for (let t = -1.4; t < 1.4; t += 0.05) vertex(a / cos(t), b * tan(t)); endShape();
        beginShape(); for (let t = -1.4; t < 1.4; t += 0.05) vertex(-a / cos(t), b * tan(t)); endShape();

        let targetF = activeLightSource === 1 ? createVector(-c, 0) : createVector(c, 0);
        let otherF = activeLightSource === 1 ? createVector(c, 0) : createVector(-c, 0);
        
        fill(255, 200, 0); ellipse(targetF.x, targetF.y, 12/zoom);
        drawSubText("F", activeLightSource === 1 ? "â‚" : "â‚‚", targetF.x, -20/zoom, 16/zoom);
        drawSubText("F", activeLightSource === 1 ? "â‚‚" : "â‚", otherF.x, -20/zoom, 16/zoom);

        if (mouseIsPressed && !isOverUI() && frameCount % 5 === 0) {
            let start = createVector(worldMX, worldMY);
            let dir = p5.Vector.sub(targetF, start).normalize();
            
            let Aq = pow(dir.x/a, 2) - pow(dir.y/b, 2);
            let Bq = 2 * (start.x*dir.x/pow(a,2) - start.y*dir.y/pow(b,2));
            let Cq = pow(start.x/a, 2) - pow(start.y/b, 2) - 1;
            let det = Bq*Bq - 4*Aq*Cq;

            if (det >= 0) {
                let k = (-Bq - sqrt(det)) / (2*Aq);
                if (k < 0) k = (-Bq + sqrt(det)) / (2*Aq);
                if (k > 0) {
                    let hit = p5.Vector.add(start, p5.Vector.mult(dir, k));
                    let reflectDir = p5.Vector.sub(otherF, hit).normalize();
                    rays.push({path: [start, hit, p5.Vector.add(hit, p5.Vector.mult(reflectDir, 2000))], progress: 0});
                }
            }
        }

        for (let i = rays.length-1; i>=0; i--) {
            let r = rays[i]; r.progress += 20/zoom;
            stroke(255, 215, 0); strokeWeight(4/zoom);
            let p1 = r.path[0], p2 = r.path[1], p3 = r.path[2];
            let d1 = dist(p1.x, p1.y, p2.x, p2.y);
            if (r.progress < d1) {
                let pos = p5.Vector.lerp(p1, p2, r.progress/d1);
                line(p1.x, p1.y, pos.x, pos.y);
            } else {
                line(p1.x, p1.y, p2.x, p2.y);
                let d2 = dist(p2.x, p2.y, p3.x, p3.y);
                let pos = p5.Vector.lerp(p2, p3, (r.progress-d1)/d2);
                line(p2.x, p2.y, pos.x, pos.y);
            }
            if (r.progress > 3000) rays.splice(i, 1);
        }
    }

    function getIntersection(p1, v1, p2, v2) {
        let det = v1.x * v2.y - v1.y * v2.x;
        if (abs(det) < 0.001) return null;
        let t = ((p2.x - p1.x) * v2.y - (p2.y - p1.y) * v2.x) / det;
        return createVector(p1.x + t * v1.x, p1.y + t * v1.y);
    }

    function setMode(m) {
        mode = m;
        document.querySelectorAll('.tab').forEach((t, i) => t.classList.toggle('active', i === m-1));
        document.getElementById('lightSwitchBtn').style.display = (m === 3) ? 'block' : 'none';
        document.getElementById('angleUi').style.display = (m === 3) ? 'flex' : 'none';
        updateInstruction(); updateInfoText();
    }

    function toggleInfo() { isInfoOpen = !isInfoOpen; document.getElementById('infoBox').style.display = isInfoOpen ? 'block' : 'none'; updateInfoText(); }
    function updateInfoText() { if (isInfoOpen) document.getElementById('infoBox').innerHTML = conceptTexts[mode]; }
    function updateInstruction() {
        const ins = [
            "í™”ë©´ì„ í´ë¦­í•˜ì—¬ ì  Aë¥¼ ì›€ì§ì´ë©´ ìŒê³¡ì„  ìì·¨ê°€ ê·¸ë ¤ì§‘ë‹ˆë‹¤.",
            "ìŒê³¡ì„  ìœ„ë¥¼ í´ë¦­í•´ ë³´ì„¸ìš”. ë‘ ì´ˆì ê¹Œì§€ì˜ ê±°ë¦¬ì˜ ì°¨ê°€ í‘œì‹œë©ë‹ˆë‹¤.",
            "í™”ë©´ì„ í´ë¦­í•˜ë©´ ë¹›ì´ ë°œì‚¬ë©ë‹ˆë‹¤. ë¹›ì€ ë°˜ëŒ€í¸ ì´ˆì ì„ í–¥í•´ ë°˜ì‚¬ë©ë‹ˆë‹¤."
        ];
        document.getElementById('instructions').innerHTML = ins[mode-1];
    }
    function resetData() { tracePoints = []; activePoint = null; rays = []; }
    function resetView() { zoom = 1.0; offsetX = 0; offsetY = 0; }
    function drawGrid() { stroke(240); for(let i=-2000; i<2000; i+=50) { line(i,-2000,i,2000); line(-2000,i,2000,i); } }
    function isOverUI() { return mouseX < 250 && mouseY < 400; }
    function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
