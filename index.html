<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í¬ë¬¼ì„ ì˜ íŠ¹ì§• by ET</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #f8f9fa; font-family: 'Pretendard', sans-serif; }
        
        #header { position: absolute; top: 0; width: 100%; background: #1a1a2e; color: white; text-align: center; padding: 12px 0; font-size: 24px; font-weight: 800; z-index: 1002; letter-spacing: 1px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); }
        #header span { color: #00d2ff; font-size: 16px; font-weight: normal; margin-left: 8px; }
        
        #menu { position: absolute; top: 52px; width: 100%; display: flex; justify-content: center; background: rgba(255, 255, 255, 0.95); box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; }
        .tab { padding: 15px 25px; cursor: pointer; border-bottom: 3px solid transparent; font-weight: bold; color: #555; transition: 0.3s; }
        .tab.active { border-bottom: 3px solid #007bff; color: #007bff; }
        
        #ui-layer { position: absolute; top: 120px; left: 20px; z-index: 1001; display: flex; flex-direction: column; gap: 10px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .ui-item { display: flex; align-items: center; gap: 8px; }
        .ui-item label { font-size: 14px; font-weight: bold; color: #333; min-width: 90px; }

        button { padding: 10px 15px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: background 0.2s; }
        button:hover { filter: brightness(1.1); }
        button.reset { background: #ff3b30; margin-top: 5px; }
        button.info { background: #17a2b8; margin-top: 5px; }
        
        input[type=range] { -webkit-appearance: none; width: 140px; height: 8px; border-radius: 5px; background: #d3d3d3; outline: none; transition: .2s; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #007bff; cursor: pointer; box-shadow: 0 0 5px rgba(0,0,0,0.2); }
        
        #angleUi { display: none; align-items: center; background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 8px; font-weight: bold; font-size: 14px; color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; border: 2px solid #007bff; margin-top: 5px;}
        #angleUi input { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }

        #infoBox { display: none; position: absolute; top: 120px; right: 20px; width: 320px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border-left: 5px solid #17a2b8; font-size: 14px; line-height: 1.6; color: #333; z-index: 1001; }
        #infoBox h3 { margin-top: 0; margin-bottom: 12px; color: #17a2b8; font-size: 18px; }

        #mathBox { display: none; position: absolute; bottom: 80px; left: 20px; background: rgba(255, 255, 255, 0.95); padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); border-left: 5px solid #007bff; font-size: 14px; line-height: 1.6; color: #333; z-index: 1001; pointer-events: none; }

        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 12px 24px; border-radius: 30px; font-size: 14px; pointer-events: none; z-index: 1001; text-align: center; line-height: 1.5; white-space: nowrap; }
    </style>
</head>
<body>

<div id="header">í¬ë¬¼ì„ ì˜ íŠ¹ì§•<span>by ET</span></div>

<div id="menu">
    <div id="tab1" class="tab active" onclick="setMode(1)">1. ìì·¨ ì‘ë„</div>
    <div id="tab2" class="tab" onclick="setMode(2)">2. ì •ì˜ í•™ìŠµ</div>
    <div id="tab3" class="tab" onclick="setMode(3)">3. ê´‘í•™ ì„±ì§ˆ</div>
</div>

<div id="ui-layer">
    <div class="ui-item">
        <label>ì´ˆì  ê±°ë¦¬ (p):</label>
        <input type="range" id="pSlider" min="20" max="200" value="80" step="10">
        <span id="pValue">80</span>
    </div>
    <button id="resetBtn" class="reset" onclick="resetData()">ë°ì´í„° ì´ˆê¸°í™”</button>
    <button onclick="resetView()">í™”ë©´ ìœ„ì¹˜ ì´ˆê¸°í™”</button>
    
    <label id="angleUi">
        <input type="checkbox" id="angleCheck"> ì…ì‚¬ê° / ë°˜ì‚¬ê° ë³´ê¸°
    </label>

    <button id="infoToggleBtn" class="info" onclick="toggleInfo()">ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°</button>
</div>

<div id="mathBox"></div>
<div id="infoBox"></div>
<div id="instructions"></div>

<script>
    let mode = 1;
    let zoom = 1.0;
    let offsetX = 0, offsetY = 0;
    
    let p = 80;

    let tracePoints = [];
    let activeY = null;
    let rays = [];

    let isInfoOpen = false;
    const conceptTexts = {
        1: "<h3>ìì·¨ ì‘ë„ ì›ë¦¬</h3>í¬ë¬¼ì„ ì€ <b>ì´ˆì (F)ê³¼ ì¤€ì„ (l)ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ê°€ ê°™ì€ ì ë“¤ì˜ ì§‘í•©</b>ì…ë‹ˆë‹¤.<br><br>ì¤€ì„  ìœ„ì— ìˆëŠ” ì  Aë¥¼ ìœ„ì•„ë˜ë¡œ ì›€ì§ì—¬ ê¶¤ì ì„ ê·¸ë ¤ë³´ì„¸ìš”. í¬ë¬¼ì„  ìœ„ì˜ ì  Pê°€ ê·¸ë ¤ì§‘ë‹ˆë‹¤.",
        2: "<h3>í¬ë¬¼ì„ ì˜ ì •ì˜ì™€ ê³µì‹</h3>ì–´ëŠ ìœ„ì¹˜ì— ìˆë“  <b>ì´ˆì ê¹Œì§€ì˜ ê±°ë¦¬(dâ‚)ì™€ ì¤€ì„ ê¹Œì§€ì˜ ê±°ë¦¬(dâ‚‚)ê°€ ê°™ìŠµë‹ˆë‹¤.</b><br><br>ë§ˆìš°ìŠ¤ë¥¼ <b>ì´ˆì (ë¹¨ê°„ ì )</b>ì´ë‚˜ <b>ì¤€ì„ (ë¹¨ê°„ ì„ )</b>ì— ì˜¬ë ¤ ì‹ì„ í™•ì¸í•´ ë³´ì„¸ìš”.",
        3: "<h3>í¬ë¬¼ì„ ì˜ ê´‘í•™ì  ì„±ì§ˆ</h3>í¬ë¬¼ì„ ì˜ ì¶•ê³¼ <b>í‰í–‰í•˜ê²Œ ë“¤ì–´ì˜¨ ë¹›</b>ì€ í¬ë¬¼ì„  ë©´ì— ë¶€ë”ªíŒ í›„ <b>í•­ìƒ ì´ˆì (F)ì„ í–¥í•´ ëª¨ì…ë‹ˆë‹¤.</b><br><br><b>ì•ˆìª½</b>ì—ì„œ ë¹›ì„ ì˜ë©´: ë¹›ì´ í¬ë¬¼ì„ ì— ë°˜ì‚¬ë˜ì–´ ì´ˆì ì„ ì§€ë‚œ í›„ ë‹¤ì‹œ í¬ë¬¼ì„ ì— ë°˜ì‚¬ë˜ì–´ ì¶•ê³¼ í‰í–‰í•˜ê²Œ ë‚˜ê°‘ë‹ˆë‹¤.<br><b>ë°”ê¹¥ìª½</b>ì—ì„œ ë¹›ì„ ì˜ë©´: í¬ë¬¼ì„ ì˜ ë³¼ë¡í•œ ë©´ì— ë¶€ë”ªíŒ ë’¤, ë§ˆì¹˜ ì´ˆì ì—ì„œ ë»—ì–´ë‚˜ì˜¨ ê²ƒì²˜ëŸ¼ ë°˜ì‚¬ë©ë‹ˆë‹¤."
    };

    function setup() {
        createCanvas(windowWidth, windowHeight);
        document.oncontextmenu = () => false;

        let pSlider = select('#pSlider');
        let pVal = select('#pValue');

        pSlider.input(() => {
            p = parseInt(pSlider.value());
            pVal.html(pSlider.value());
            updateMathInfo();
            resetData();
        });

        updateMathInfo();
        updateInstruction();
    }

    function updateMathInfo() {
        let html = `
            <div style="font-size:15px; margin-bottom:10px; color:#007bff; font-weight:bold;">[ ì‹¤ì‹œê°„ í¬ë¬¼ì„ ì˜ ë°©ì •ì‹ ]</div>
            <div style="display:flex; justify-content:center; align-items:center; font-size: 20px; margin-bottom:15px; font-family: serif;">
                y<sup>2</sup> = 4(${p})x = ${4*p}x
            </div>
            <hr style="border:0; border-top:1px dashed #ccc; margin:10px 0;">
            <div style="font-size:14px; line-height: 1.8;">
                <b>â€¢ ê³µì‹:</b> y<sup>2</sup> = 4px<br>
                <b>â€¢ ì´ˆì (F):</b> (${p}, 0)<br>
                <b>â€¢ ì¤€ì„ (l):</b> x = -${p}<br>
                <b>â€¢ ê¼­ì§“ì :</b> (0, 0)
            </div>
        `;
        document.getElementById('mathBox').innerHTML = html;
    }

    function draw() {
        background(255);
        
        push();
        translate(width/2 + offsetX, height/2 + offsetY);
        scale(zoom);
        drawGrid();

        if (mode === 1) runMode1();
        else if (mode === 2) runMode2();
        else if (mode === 3) runMode3();
        
        pop();
    }

    // Yì¶• ê·¸ë¦´ ë•Œ UI ì¹´í…Œê³ ë¦¬ ì¹¨ë²”ì„ ë°©ì§€í•˜ëŠ” í•¨ìˆ˜
    function getSafeYTop() {
        return (-height/2 + 150) / zoom;
    }

    function runMode1() {
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        let safeYTop = getSafeYTop();

        // ì´ˆì (F)ê³¼ ì¤€ì„ (l) ê·¸ë¦¬ê¸°
        fill(255, 59, 48); noStroke(); ellipse(p, 0, 15/zoom);
        stroke(255, 59, 48); strokeWeight(2/zoom); line(-p, -2000, -p, 2000);
        
        fill(0); textSize(16/zoom); textAlign(CENTER, BASELINE);
        text("F", p, -15/zoom);
        textAlign(RIGHT, CENTER); text("ì¤€ì„ (l)", -p - 10/zoom, safeYTop + 50/zoom);

        // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ ì  A ì¡°ì‘ ë° ìì·¨ ê·¸ë¦¬ê¸°
        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            let my = worldMY;
            let px = (my * my) / (4 * p);
            
            tracePoints.push({x: px, y: my});
            
            // ì  A (ì¤€ì„  ìœ„)
            fill(0); noStroke(); ellipse(-p, my, 12/zoom);
            textAlign(RIGHT, CENTER); textSize(16/zoom); textStyle(BOLD); text("A", -p - 15/zoom, my); textStyle(NORMAL);
            
            // ì  P (í¬ë¬¼ì„  ìœ„)
            fill(100); noStroke(); ellipse(px, my, 12/zoom);
            textAlign(LEFT, BOTTOM); textSize(16/zoom); textStyle(BOLD); text("P", px + 15/zoom, my - 5/zoom); textStyle(NORMAL);

            // ì—°ê²°ì„ 
            stroke(34, 197, 94); strokeWeight(3/zoom);
            line(-p, my, px, my); // A to P
            line(px, my, p, 0);   // P to F
            
            let d1 = dist(px, my, p, 0);

            // d1, d2 í…ìŠ¤íŠ¸ (ë°©í•´ë˜ì§€ ì•Šê²Œ ì„  ê³ì—)
            fill(0); textSize(16/zoom); textAlign(CENTER);
            text("dâ‚‚", (-p + px)/2, my - 10/zoom);
            text("dâ‚", (px + p)/2, my/2 - 10/zoom);
            
            // ìƒë‹¨ ë¶„ë¦¬ëœ íˆ´íŒ (ê±°ë¦¬ê°€ ê°™ìŒ)
            fill(0, 122, 255); textSize(20/zoom); textStyle(BOLD);
            text(`ê±°ë¦¬ì˜ ì°¨ê°€ ì—†ìŠµë‹ˆë‹¤!  dâ‚ = dâ‚‚ = ${d1.toFixed(1)}`, 0, safeYTop + 30/zoom);
            textStyle(NORMAL);
        }

        // ê¶¤ì  ê·¸ë¦¬ê¸°
        noFill(); stroke(0, 122, 255); strokeWeight(4/zoom);
        for (let pt of tracePoints) point(pt.x, pt.y);
    }

    function runMode2() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;
        let safeYTop = getSafeYTop(); // ì¹´í…Œê³ ë¦¬ë¥¼ ì¹¨ë²”í•˜ì§€ ì•ŠëŠ” ì„ 

        // 1. xì¶•, yì¶• ê·¸ë¦¬ê¸° (í™”ì‚´í‘œ ì¶”ê°€)
        stroke(100); strokeWeight(2/zoom);
        let xMax = (width/2 - 20)/zoom;
        line(-2000, 0, xMax, 0); // xì¶•
        line(0, 2000, 0, safeYTop); // yì¶•
        
        fill(100); noStroke();
        triangle(xMax, 0, xMax - 15/zoom, -6/zoom, xMax - 15/zoom, 6/zoom); // xì¶• í™”ì‚´í‘œ
        triangle(0, safeYTop, -6/zoom, safeYTop + 15/zoom, 6/zoom, safeYTop + 15/zoom); // yì¶• í™”ì‚´í‘œ
        
        textSize(16/zoom); textAlign(LEFT, BASELINE);
        text("xì¶•", xMax - 30/zoom, -15/zoom);
        text("yì¶•", 15/zoom, safeYTop + 15/zoom);
        
        // ì›ì  O í‘œì‹œ (ì•„ë˜ ì™¼ìª½)
        textAlign(RIGHT, TOP);
        text("O", -8/zoom, 8/zoom);

        // 2. í¬ë¬¼ì„  ê·¸ë¦¬ê¸°
        noFill(); stroke(0, 122, 255); strokeWeight(3/zoom);
        beginShape();
        for (let y = -1500/zoom; y <= 1500/zoom; y += 10/zoom) {
            let x = (y * y) / (4 * p);
            vertex(x, y);
        }
        endShape();

        let isOverF = dist(worldMX, worldMY, p, 0) < 20/zoom && !isOverUI();
        let isOverL = abs(worldMX - (-p)) < 15/zoom && !isOverUI();

        // ì¤€ì„ 
        stroke(255, 59, 48); strokeWeight(isOverL ? 5/zoom : 2/zoom);
        line(-p, -2000, -p, 2000);

        // ì´ˆì 
        fill(255, 59, 48); noStroke();
        ellipse(p, 0, isOverF ? 20/zoom : 12/zoom);

        if (isOverF) {
            fill(0); textSize(16/zoom); textStyle(BOLD); textAlign(CENTER, BOTTOM);
            text(`ì´ˆì  F(${p}, 0)`, p, -20/zoom);
            textStyle(NORMAL);
        } else if (!isOverF && !activeY) {
            fill(0); textSize(14/zoom); textAlign(CENTER, BOTTOM); text("F", p, -15/zoom);
        }

        if (isOverL) {
            fill(0); textSize(16/zoom); textStyle(BOLD); textAlign(RIGHT, CENTER);
            text(`ì¤€ì„  x = -${p}`, -p - 15/zoom, worldMY);
            textStyle(NORMAL);
        }

        // 5. í´ë¦­ ì‹œ ê³ ì •
        if (mouseIsPressed && !isOverUI() && !isOverF && !isOverL) {
            activeY = worldMY;
        }

        if (activeY !== null) {
            let px = (activeY * activeY) / (4 * p);
            let py = activeY;
            
            stroke(34, 197, 94); strokeWeight(3/zoom);
            line(px, py, p, 0);      
            line(px, py, -p, py);    
            
            fill(34, 197, 94); noStroke(); ellipse(px, py, 12/zoom);
            fill(0); noStroke(); ellipse(-p, py, 10/zoom); // ì¤€ì„  ìœ„ ì 
            
            let d1 = dist(px, py, p, 0);
            
            fill(0); textSize(16/zoom); textAlign(CENTER);
            text("dâ‚", (px + p)/2, py/2 - 10/zoom);
            text("dâ‚‚", (px - p)/2, py - 10/zoom);
            
            // ë°©í•´ë˜ì§€ ì•Šë„ë¡ ìƒë‹¨ì— íˆ´íŒ ê³ ì • ë°°ì¹˜
            fill(0, 122, 255); textSize(20/zoom); textStyle(BOLD);
            text(`dâ‚ = dâ‚‚ = ${d1.toFixed(1)}`, 0, safeYTop + 30/zoom);
            textStyle(NORMAL);
        }
    }

    function runMode3() {
        let worldMX = (mouseX - width/2 - offsetX) / zoom;
        let worldMY = (mouseY - height/2 - offsetY) / zoom;

        // í¬ë¬¼ì„ 
        noFill(); stroke(0, 122, 255); strokeWeight(3/zoom);
        beginShape();
        for (let y = -1500/zoom; y <= 1500/zoom; y += 10/zoom) {
            vertex((y * y) / (4 * p), y);
        }
        endShape();

        // ì´ˆì 
        fill(255, 59, 48); noStroke(); ellipse(p, 0, 15/zoom);
        fill(0); textSize(16/zoom); textAlign(CENTER, BASELINE); text("F", p, -15/zoom);

        if(!isOverUI()) {
            fill(255, 215, 0); noStroke(); ellipse(worldMX, worldMY, 12/zoom);
        }

        if (mouseIsPressed && mouseButton === LEFT && !isOverUI()) {
            if (frameCount % 10 === 0) {
                let mx = worldMX;
                let my = worldMY;
                if (abs(my) < 5/zoom) my = 5/zoom; // 0ìœ¼ë¡œ ì¸í•œ ê³„ì‚° ì˜¤ë¥˜ ë°©ì§€
                
                let px = (my * my) / (4 * p); 
                let isInside = mx > px; // ì•ˆìª½ì¸ì§€ ë°”ê¹¥ìª½ì¸ì§€ íŒë³„

                let bouncePath = [];
                let p_start = createVector(mx, my);
                
                if (isInside) {
                    // ì•ˆìª½ì—ì„œ ìœ ë¹› (ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬ -> í¬ë¬¼ì„  -> ì´ˆì  -> í¬ë¬¼ì„  -> ì˜¤ë¥¸ìª½ ë°©í–¥)
                    let p_hit1 = createVector(px, my);
                    let p_f = createVector(p, 0);
                    
                    let t1 = my / (2 * p);
                    let t2 = -1 / t1; 
                    let p_hit2 = createVector(p * t2 * t2, 2 * p * t2);
                    let p_end = createVector(p_hit2.x + 2000, p_hit2.y);
                    
                    bouncePath = [p_start, p_hit1, p_f, p_hit2, p_end];
                } else {
                    // ë°”ê¹¥ìª½ì—ì„œ ìœ ë¹› (ì˜¤ë¥¸ìª½ ë°©í–¥ìœ¼ë¡œ ë°œì‚¬ -> ë³¼ë¡ë©´ì— íŠ•ê¹€ -> ì´ˆì ì—ì„œ ë©€ì–´ì§€ëŠ” ë°©í–¥)
                    let p_hit = createVector(px, my);
                    // ë¹›ì´ Fì—ì„œ ë»—ì–´ë‚˜ê°€ëŠ” ë°©í–¥ê³¼ ë™ì¼í•˜ê²Œ ë°˜ì‚¬ë¨
                    let dirRef = p5.Vector.sub(p_hit, createVector(p, 0)).normalize();
                    let p_end = createVector(p_hit.x + dirRef.x * 2000, p_hit.y + dirRef.y * 2000);
                    
                    bouncePath = [p_start, p_hit, p_end];
                }

                let dists = [];
                let totalD = 0;
                for(let i=0; i<bouncePath.length-1; i++) {
                    let d = p5.Vector.dist(bouncePath[i], bouncePath[i+1]);
                    dists.push(d); totalD += d;
                }
                let sumDists = [0];
                for(let i=0; i<dists.length; i++) sumDists.push(sumDists[i] + dists[i]);

                rays.push({ path: bouncePath, dists: dists, sumDists: sumDists, progress: 0, totalDist: totalD, isInside: isInside });
            }
        }

        let speed = 40 / zoom;
        let beamLen = 150 / zoom; 
        let showAngle = document.getElementById('angleCheck').checked;

        for (let i = rays.length - 1; i >= 0; i--) {
            let r = rays[i];
            r.progress += speed;

            stroke(255, 204, 0, 30); strokeWeight(2/zoom);
            line(r.path[0].x, r.path[0].y, r.path[1].x, r.path[1].y); 

            let head = r.progress;
            let tail = max(0, r.progress - beamLen);

            noFill(); stroke(255, 220, 0); strokeWeight(6/zoom);
            beginShape();
            for (let d = tail; d <= head; d += 5/zoom) {
                let pos = getPosAlongPath(r.path, r.dists, d);
                vertex(pos.x, pos.y);
            }
            let headPos = getPosAlongPath(r.path, r.dists, head);
            vertex(headPos.x, headPos.y);
            endShape();

            noStroke(); fill(255, 255, 255, 200); ellipse(headPos.x, headPos.y, 8/zoom);

            // ì²« ë²ˆì§¸ ë¶€ë”ªíŒ ê³³(path[1])ì—ì„œë§Œ ì…ì‚¬ê°/ë°˜ì‚¬ê° í‘œì‹œ
            if (showAngle && r.progress > r.sumDists[1]) {
                let px = r.path[1].x; let py = r.path[1].y;
                
                let slopeTan = py === 0 ? 9999 : (2 * p) / py;
                let vTan = createVector(1, slopeTan).normalize();
                let vNorm = createVector(-vTan.y, vTan.x); 
                
                let vInc = p5.Vector.sub(r.path[1], r.path[0]).normalize();
                // ë²•ì„  ë²¡í„°ê°€ ê´‘ì„ ì´ ë‚ ì•„ì˜¤ëŠ” ìª½ì„ í–¥í•˜ë„ë¡ (ë‚´ì ê°’ ìŒìˆ˜)
                if (vNorm.dot(vInc) > 0) vNorm.mult(-1);
                
                stroke(40, 167, 69, 150); strokeWeight(2/zoom); drawingContext.setLineDash([6, 6]);
                line(px - vTan.x*100/zoom, py - vTan.y*100/zoom, px + vTan.x*100/zoom, py + vTan.y*100/zoom);
                drawingContext.setLineDash([]);
                
                fill(40, 167, 69); noStroke(); textStyle(BOLD); textSize(14/zoom); textAlign(CENTER, CENTER);
                text("ì ‘ì„ ", px + vTan.x * 110 / zoom, py + vTan.y * 110 / zoom);

                stroke(255, 136, 0, 180); strokeWeight(2/zoom);
                line(px, py, px + vNorm.x*80/zoom, py + vNorm.y*80/zoom);

                let vRef = p5.Vector.sub(r.path[2], r.path[1]).normalize();
                let angleDeg = degrees(acos(vInc.dot(vNorm)* -1)).toFixed(1); // ì…ì‚¬ê° ê³„ì‚° ë³´ì •

                let rArc = 40 / zoom;
                noFill(); stroke(255, 100, 0, 150); strokeWeight(2/zoom);
                let drawArc = (v1, v2) => {
                    let a1 = v1.heading(); let a2 = v2.heading();
                    let start = min(a1, a2); let stop = max(a1, a2);
                    if (stop - start > PI) { start = stop; stop = min(a1,a2) + TWO_PI; }
                    arc(px, py, rArc*2, rArc*2, start, stop);
                };
                drawArc(vNorm, p5.Vector.mult(vInc, -1)); // ë“¤ì–´ì˜¤ëŠ” ë°©í–¥ ê±°ê¾¸ë¡œ í•˜ì—¬ ê°ë„ ê·¸ë¦¬ê¸°
                drawArc(vNorm, vRef);

                fill(255, 100, 0); noStroke(); textSize(12/zoom); textAlign(CENTER, CENTER);
                let txtInc = p5.Vector.add(p5.Vector.mult(vInc, -1), vNorm).normalize().mult(60/zoom);
                let txtRef = p5.Vector.add(vRef, vNorm).normalize().mult(60/zoom);
                text(angleDeg + "Â°", px + txtInc.x, py + txtInc.y);
                text(angleDeg + "Â°", px + txtRef.x, py + txtRef.y);
            }
            if (tail > r.totalDist) rays.splice(i, 1);
        }
    }

    function getPosAlongPath(path, dists, d) {
        if (d <= 0) return path[0];
        let currentDist = 0;
        for (let i = 0; i < dists.length; i++) {
            if (d <= currentDist + dists[i]) {
                let t = (d - currentDist) / dists[i];
                return p5.Vector.lerp(path[i], path[i+1], t);
            }
            currentDist += dists[i];
        }
        return path[path.length - 1];
    }

    function setMode(m) {
        mode = m;
        activeY = null;
        document.getElementById('tab1').classList.toggle('active', m === 1);
        document.getElementById('tab2').classList.toggle('active', m === 2);
        document.getElementById('tab3').classList.toggle('active', m === 3);
        
        document.getElementById('angleUi').style.display = (m === 3) ? 'flex' : 'none';
        document.getElementById('mathBox').style.display = (m === 2) ? 'block' : 'none';
        
        updateInstruction();
        updateInfoText();
    }

    function toggleInfo() {
        isInfoOpen = !isInfoOpen;
        let btn = document.getElementById('infoToggleBtn');
        let box = document.getElementById('infoBox');
        if (isInfoOpen) { btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ë„ê¸°"; box.style.display = "block"; updateInfoText(); } 
        else { btn.innerText = "ğŸ“– ê°œë… ì„¤ëª… ì¼œê¸°"; box.style.display = "none"; }
    }

    function updateInfoText() { if (isInfoOpen) document.getElementById('infoBox').innerHTML = conceptTexts[mode]; }

    function updateInstruction() {
        let ins = document.getElementById('instructions');
        if (mode === 1) ins.innerHTML = "<b>ì¤€ì„  ìœ„ì˜ ì  A(ë§ˆìš°ìŠ¤ ìœ„ì¹˜)</b>ë¥¼ ìœ„ì•„ë˜ë¡œ ì›€ì§ì—¬ ê¶¤ì ì„ ê·¸ë ¤ë³´ì„¸ìš”.";
        else if (mode === 2) ins.innerHTML = "<b>ì´ˆì (ë¹¨ê°„ ì )ì´ë‚˜ ì¤€ì„ (ë¹¨ê°„ ì„ )ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë ¤ë³´ì„¸ìš”.</b><br>ë¹ˆ ê³µê°„ì„ <b>í´ë¦­</b>í•˜ë©´ ì ê³¼ ê±°ë¦¬ê°€ ê³ ì •ë©ë‹ˆë‹¤.";
        else if (mode === 3) ins.innerHTML = "ë§ˆìš°ìŠ¤ë¥¼ í¬ë¬¼ì„  <b>ì•ˆ/ë°–ìœ¼ë¡œ ì›€ì§ì´ë©° í´ë¦­</b>(ë¹› ë°œì‚¬) í•´ë³´ì„¸ìš”.";
    }

    function resetData() { tracePoints = []; activeY = null; rays = []; }
    function mouseDragged() { if (mouseButton === RIGHT) { offsetX += mouseX - pmouseX; offsetY += mouseY - pmouseY; } }
    function mouseWheel(event) { zoom = constrain(zoom - event.delta * 0.001, 0.2, 4); return false; }
    
    function isOverUI() { 
        let inLeftMenu = mouseY < 280 && mouseX < 260;
        let inRightInfo = isInfoOpen && (mouseX > width - 360 && mouseY < 400); 
        return inLeftMenu || inRightInfo;
    } 

    function resetView() { zoom = 1.0; offsetX = 0; offsetY = 0; }
    function drawGrid() { stroke(240); strokeWeight(1/zoom); for (let i = -2000; i < 2000; i += 50) line(i, -2000, i, 2000); for (let j = -2000; j < 2000; j += 50) line(-2000, j, 2000, j); }
    function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
